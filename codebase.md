# .gitignore

```
# IDE and OS .idea .vscode .DS_Store # output bin log *.log *.out *.out.* *.test .env .env.dev .env.docker .devbox # dependencies vendor tmp data
```

# cmd/server/main.go

```go
package main import ( "github.com/dwarvesf/icy-backend/internal/server" ) func main() { server.Init() }
```

# contracts/erc20/erc20.abi

```abi
[{"inputs":[],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"spender","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Transfer","type":"event"},{"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"spender","type":"address"}],"name":"allowance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"approve","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"burn","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"burnFrom","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"decimals","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"subtractedValue","type":"uint256"}],"name":"decreaseAllowance","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"addedValue","type":"uint256"}],"name":"increaseAllowance","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"name","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transfer","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transferFrom","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"}]
```

# contracts/erc20/erc20.go

```go
// Code generated - DO NOT EDIT. // This file is a generated binding and any manual changes will be lost. package erc20 import ( "errors" "math/big" "strings" ethereum "github.com/ethereum/go-ethereum" "github.com/ethereum/go-ethereum/accounts/abi" "github.com/ethereum/go-ethereum/accounts/abi/bind" "github.com/ethereum/go-ethereum/common" "github.com/ethereum/go-ethereum/core/types" "github.com/ethereum/go-ethereum/event" ) // Reference imports to suppress errors if they are not otherwise used. var ( _ = errors.New _ = big.NewInt _ = strings.NewReader _ = ethereum.NotFound _ = bind.Bind _ = common.Big1 _ = types.BloomLookup _ = event.NewSubscription _ = abi.ConvertType ) // Erc20MetaData contains all meta data concerning the Erc20 contract. var Erc20MetaData = &bind.MetaData{ ABI: "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", } // Erc20ABI is the input ABI used to generate the binding from. // Deprecated: Use Erc20MetaData.ABI instead. var Erc20ABI = Erc20MetaData.ABI // Erc20 is an auto generated Go binding around an Ethereum contract. type Erc20 struct { Erc20Caller // Read-only binding to the contract Erc20Transactor // Write-only binding to the contract Erc20Filterer // Log filterer for contract events } // Erc20Caller is an auto generated read-only Go binding around an Ethereum contract. type Erc20Caller struct { contract *bind.BoundContract // Generic contract wrapper for the low level calls } // Erc20Transactor is an auto generated write-only Go binding around an Ethereum contract. type Erc20Transactor struct { contract *bind.BoundContract // Generic contract wrapper for the low level calls } // Erc20Filterer is an auto generated log filtering Go binding around an Ethereum contract events. type Erc20Filterer struct { contract *bind.BoundContract // Generic contract wrapper for the low level calls } // Erc20Session is an auto generated Go binding around an Ethereum contract, // with pre-set call and transact options. type Erc20Session struct { Contract *Erc20 // Generic contract binding to set the session for CallOpts bind.CallOpts // Call options to use throughout this session TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session } // Erc20CallerSession is an auto generated read-only Go binding around an Ethereum contract, // with pre-set call options. type Erc20CallerSession struct { Contract *Erc20Caller // Generic contract caller binding to set the session for CallOpts bind.CallOpts // Call options to use throughout this session } // Erc20TransactorSession is an auto generated write-only Go binding around an Ethereum contract, // with pre-set transact options. type Erc20TransactorSession struct { Contract *Erc20Transactor // Generic contract transactor binding to set the session for TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session } // Erc20Raw is an auto generated low-level Go binding around an Ethereum contract. type Erc20Raw struct { Contract *Erc20 // Generic contract binding to access the raw methods on } // Erc20CallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract. type Erc20CallerRaw struct { Contract *Erc20Caller // Generic read-only contract binding to access the raw methods on } // Erc20TransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract. type Erc20TransactorRaw struct { Contract *Erc20Transactor // Generic write-only contract binding to access the raw methods on } // NewErc20 creates a new instance of Erc20, bound to a specific deployed contract. func NewErc20(address common.Address, backend bind.ContractBackend) (*Erc20, error) { contract, err := bindErc20(address, backend, backend, backend) if err != nil { return nil, err } return &Erc20{Erc20Caller: Erc20Caller{contract: contract}, Erc20Transactor: Erc20Transactor{contract: contract}, Erc20Filterer: Erc20Filterer{contract: contract}}, nil } // NewErc20Caller creates a new read-only instance of Erc20, bound to a specific deployed contract. func NewErc20Caller(address common.Address, caller bind.ContractCaller) (*Erc20Caller, error) { contract, err := bindErc20(address, caller, nil, nil) if err != nil { return nil, err } return &Erc20Caller{contract: contract}, nil } // NewErc20Transactor creates a new write-only instance of Erc20, bound to a specific deployed contract. func NewErc20Transactor(address common.Address, transactor bind.ContractTransactor) (*Erc20Transactor, error) { contract, err := bindErc20(address, nil, transactor, nil) if err != nil { return nil, err } return &Erc20Transactor{contract: contract}, nil } // NewErc20Filterer creates a new log filterer instance of Erc20, bound to a specific deployed contract. func NewErc20Filterer(address common.Address, filterer bind.ContractFilterer) (*Erc20Filterer, error) { contract, err := bindErc20(address, nil, nil, filterer) if err != nil { return nil, err } return &Erc20Filterer{contract: contract}, nil } // bindErc20 binds a generic wrapper to an already deployed contract. func bindErc20(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) { parsed, err := Erc20MetaData.GetAbi() if err != nil { return nil, err } return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil } // Call invokes the (constant) contract method with params as input values and // sets the output to result. The result type might be a single field for simple // returns, a slice of interfaces for anonymous returns and a struct for named // returns. func (_Erc20 *Erc20Raw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error { return _Erc20.Contract.Erc20Caller.contract.Call(opts, result, method, params...) } // Transfer initiates a plain transaction to move funds to the contract, calling // its default method if one is available. func (_Erc20 *Erc20Raw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) { return _Erc20.Contract.Erc20Transactor.contract.Transfer(opts) } // Transact invokes the (paid) contract method with params as input values. func (_Erc20 *Erc20Raw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) { return _Erc20.Contract.Erc20Transactor.contract.Transact(opts, method, params...) } // Call invokes the (constant) contract method with params as input values and // sets the output to result. The result type might be a single field for simple // returns, a slice of interfaces for anonymous returns and a struct for named // returns. func (_Erc20 *Erc20CallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error { return _Erc20.Contract.contract.Call(opts, result, method, params...) } // Transfer initiates a plain transaction to move funds to the contract, calling // its default method if one is available. func (_Erc20 *Erc20TransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) { return _Erc20.Contract.contract.Transfer(opts) } // Transact invokes the (paid) contract method with params as input values. func (_Erc20 *Erc20TransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) { return _Erc20.Contract.contract.Transact(opts, method, params...) } // Allowance is a free data retrieval call binding the contract method 0xdd62ed3e. // // Solidity: function allowance(address owner, address spender) view returns(uint256) func (_Erc20 *Erc20Caller) Allowance(opts *bind.CallOpts, owner common.Address, spender common.Address) (*big.Int, error) { var out []interface{} err := _Erc20.contract.Call(opts, &out, "allowance", owner, spender) if err != nil { return *new(*big.Int), err } out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int) return out0, err } // Allowance is a free data retrieval call binding the contract method 0xdd62ed3e. // // Solidity: function allowance(address owner, address spender) view returns(uint256) func (_Erc20 *Erc20Session) Allowance(owner common.Address, spender common.Address) (*big.Int, error) { return _Erc20.Contract.Allowance(&_Erc20.CallOpts, owner, spender) } // Allowance is a free data retrieval call binding the contract method 0xdd62ed3e. // // Solidity: function allowance(address owner, address spender) view returns(uint256) func (_Erc20 *Erc20CallerSession) Allowance(owner common.Address, spender common.Address) (*big.Int, error) { return _Erc20.Contract.Allowance(&_Erc20.CallOpts, owner, spender) } // BalanceOf is a free data retrieval call binding the contract method 0x70a08231. // // Solidity: function balanceOf(address account) view returns(uint256) func (_Erc20 *Erc20Caller) BalanceOf(opts *bind.CallOpts, account common.Address) (*big.Int, error) { var out []interface{} err := _Erc20.contract.Call(opts, &out, "balanceOf", account) if err != nil { return *new(*big.Int), err } out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int) return out0, err } // BalanceOf is a free data retrieval call binding the contract method 0x70a08231. // // Solidity: function balanceOf(address account) view returns(uint256) func (_Erc20 *Erc20Session) BalanceOf(account common.Address) (*big.Int, error) { return _Erc20.Contract.BalanceOf(&_Erc20.CallOpts, account) } // BalanceOf is a free data retrieval call binding the contract method 0x70a08231. // // Solidity: function balanceOf(address account) view returns(uint256) func (_Erc20 *Erc20CallerSession) BalanceOf(account common.Address) (*big.Int, error) { return _Erc20.Contract.BalanceOf(&_Erc20.CallOpts, account) } // Decimals is a free data retrieval call binding the contract method 0x313ce567. // // Solidity: function decimals() view returns(uint8) func (_Erc20 *Erc20Caller) Decimals(opts *bind.CallOpts) (uint8, error) { var out []interface{} err := _Erc20.contract.Call(opts, &out, "decimals") if err != nil { return *new(uint8), err } out0 := *abi.ConvertType(out[0], new(uint8)).(*uint8) return out0, err } // Decimals is a free data retrieval call binding the contract method 0x313ce567. // // Solidity: function decimals() view returns(uint8) func (_Erc20 *Erc20Session) Decimals() (uint8, error) { return _Erc20.Contract.Decimals(&_Erc20.CallOpts) } // Decimals is a free data retrieval call binding the contract method 0x313ce567. // // Solidity: function decimals() view returns(uint8) func (_Erc20 *Erc20CallerSession) Decimals() (uint8, error) { return _Erc20.Contract.Decimals(&_Erc20.CallOpts) } // Name is a free data retrieval call binding the contract method 0x06fdde03. // // Solidity: function name() view returns(string) func (_Erc20 *Erc20Caller) Name(opts *bind.CallOpts) (string, error) { var out []interface{} err := _Erc20.contract.Call(opts, &out, "name") if err != nil { return *new(string), err } out0 := *abi.ConvertType(out[0], new(string)).(*string) return out0, err } // Name is a free data retrieval call binding the contract method 0x06fdde03. // // Solidity: function name() view returns(string) func (_Erc20 *Erc20Session) Name() (string, error) { return _Erc20.Contract.Name(&_Erc20.CallOpts) } // Name is a free data retrieval call binding the contract method 0x06fdde03. // // Solidity: function name() view returns(string) func (_Erc20 *Erc20CallerSession) Name() (string, error) { return _Erc20.Contract.Name(&_Erc20.CallOpts) } // Symbol is a free data retrieval call binding the contract method 0x95d89b41. // // Solidity: function symbol() view returns(string) func (_Erc20 *Erc20Caller) Symbol(opts *bind.CallOpts) (string, error) { var out []interface{} err := _Erc20.contract.Call(opts, &out, "symbol") if err != nil { return *new(string), err } out0 := *abi.ConvertType(out[0], new(string)).(*string) return out0, err } // Symbol is a free data retrieval call binding the contract method 0x95d89b41. // // Solidity: function symbol() view returns(string) func (_Erc20 *Erc20Session) Symbol() (string, error) { return _Erc20.Contract.Symbol(&_Erc20.CallOpts) } // Symbol is a free data retrieval call binding the contract method 0x95d89b41. // // Solidity: function symbol() view returns(string) func (_Erc20 *Erc20CallerSession) Symbol() (string, error) { return _Erc20.Contract.Symbol(&_Erc20.CallOpts) } // TotalSupply is a free data retrieval call binding the contract method 0x18160ddd. // // Solidity: function totalSupply() view returns(uint256) func (_Erc20 *Erc20Caller) TotalSupply(opts *bind.CallOpts) (*big.Int, error) { var out []interface{} err := _Erc20.contract.Call(opts, &out, "totalSupply") if err != nil { return *new(*big.Int), err } out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int) return out0, err } // TotalSupply is a free data retrieval call binding the contract method 0x18160ddd. // // Solidity: function totalSupply() view returns(uint256) func (_Erc20 *Erc20Session) TotalSupply() (*big.Int, error) { return _Erc20.Contract.TotalSupply(&_Erc20.CallOpts) } // TotalSupply is a free data retrieval call binding the contract method 0x18160ddd. // // Solidity: function totalSupply() view returns(uint256) func (_Erc20 *Erc20CallerSession) TotalSupply() (*big.Int, error) { return _Erc20.Contract.TotalSupply(&_Erc20.CallOpts) } // Approve is a paid mutator transaction binding the contract method 0x095ea7b3. // // Solidity: function approve(address spender, uint256 amount) returns(bool) func (_Erc20 *Erc20Transactor) Approve(opts *bind.TransactOpts, spender common.Address, amount *big.Int) (*types.Transaction, error) { return _Erc20.contract.Transact(opts, "approve", spender, amount) } // Approve is a paid mutator transaction binding the contract method 0x095ea7b3. // // Solidity: function approve(address spender, uint256 amount) returns(bool) func (_Erc20 *Erc20Session) Approve(spender common.Address, amount *big.Int) (*types.Transaction, error) { return _Erc20.Contract.Approve(&_Erc20.TransactOpts, spender, amount) } // Approve is a paid mutator transaction binding the contract method 0x095ea7b3. // // Solidity: function approve(address spender, uint256 amount) returns(bool) func (_Erc20 *Erc20TransactorSession) Approve(spender common.Address, amount *big.Int) (*types.Transaction, error) { return _Erc20.Contract.Approve(&_Erc20.TransactOpts, spender, amount) } // Burn is a paid mutator transaction binding the contract method 0x42966c68. // // Solidity: function burn(uint256 amount) returns() func (_Erc20 *Erc20Transactor) Burn(opts *bind.TransactOpts, amount *big.Int) (*types.Transaction, error) { return _Erc20.contract.Transact(opts, "burn", amount) } // Burn is a paid mutator transaction binding the contract method 0x42966c68. // // Solidity: function burn(uint256 amount) returns() func (_Erc20 *Erc20Session) Burn(amount *big.Int) (*types.Transaction, error) { return _Erc20.Contract.Burn(&_Erc20.TransactOpts, amount) } // Burn is a paid mutator transaction binding the contract method 0x42966c68. // // Solidity: function burn(uint256 amount) returns() func (_Erc20 *Erc20TransactorSession) Burn(amount *big.Int) (*types.Transaction, error) { return _Erc20.Contract.Burn(&_Erc20.TransactOpts, amount) } // BurnFrom is a paid mutator transaction binding the contract method 0x79cc6790. // // Solidity: function burnFrom(address account, uint256 amount) returns() func (_Erc20 *Erc20Transactor) BurnFrom(opts *bind.TransactOpts, account common.Address, amount *big.Int) (*types.Transaction, error) { return _Erc20.contract.Transact(opts, "burnFrom", account, amount) } // BurnFrom is a paid mutator transaction binding the contract method 0x79cc6790. // // Solidity: function burnFrom(address account, uint256 amount) returns() func (_Erc20 *Erc20Session) BurnFrom(account common.Address, amount *big.Int) (*types.Transaction, error) { return _Erc20.Contract.BurnFrom(&_Erc20.TransactOpts, account, amount) } // BurnFrom is a paid mutator transaction binding the contract method 0x79cc6790. // // Solidity: function burnFrom(address account, uint256 amount) returns() func (_Erc20 *Erc20TransactorSession) BurnFrom(account common.Address, amount *big.Int) (*types.Transaction, error) { return _Erc20.Contract.BurnFrom(&_Erc20.TransactOpts, account, amount) } // DecreaseAllowance is a paid mutator transaction binding the contract method 0xa457c2d7. // // Solidity: function decreaseAllowance(address spender, uint256 subtractedValue) returns(bool) func (_Erc20 *Erc20Transactor) DecreaseAllowance(opts *bind.TransactOpts, spender common.Address, subtractedValue *big.Int) (*types.Transaction, error) { return _Erc20.contract.Transact(opts, "decreaseAllowance", spender, subtractedValue) } // DecreaseAllowance is a paid mutator transaction binding the contract method 0xa457c2d7. // // Solidity: function decreaseAllowance(address spender, uint256 subtractedValue) returns(bool) func (_Erc20 *Erc20Session) DecreaseAllowance(spender common.Address, subtractedValue *big.Int) (*types.Transaction, error) { return _Erc20.Contract.DecreaseAllowance(&_Erc20.TransactOpts, spender, subtractedValue) } // DecreaseAllowance is a paid mutator transaction binding the contract method 0xa457c2d7. // // Solidity: function decreaseAllowance(address spender, uint256 subtractedValue) returns(bool) func (_Erc20 *Erc20TransactorSession) DecreaseAllowance(spender common.Address, subtractedValue *big.Int) (*types.Transaction, error) { return _Erc20.Contract.DecreaseAllowance(&_Erc20.TransactOpts, spender, subtractedValue) } // IncreaseAllowance is a paid mutator transaction binding the contract method 0x39509351. // // Solidity: function increaseAllowance(address spender, uint256 addedValue) returns(bool) func (_Erc20 *Erc20Transactor) IncreaseAllowance(opts *bind.TransactOpts, spender common.Address, addedValue *big.Int) (*types.Transaction, error) { return _Erc20.contract.Transact(opts, "increaseAllowance", spender, addedValue) } // IncreaseAllowance is a paid mutator transaction binding the contract method 0x39509351. // // Solidity: function increaseAllowance(address spender, uint256 addedValue) returns(bool) func (_Erc20 *Erc20Session) IncreaseAllowance(spender common.Address, addedValue *big.Int) (*types.Transaction, error) { return _Erc20.Contract.IncreaseAllowance(&_Erc20.TransactOpts, spender, addedValue) } // IncreaseAllowance is a paid mutator transaction binding the contract method 0x39509351. // // Solidity: function increaseAllowance(address spender, uint256 addedValue) returns(bool) func (_Erc20 *Erc20TransactorSession) IncreaseAllowance(spender common.Address, addedValue *big.Int) (*types.Transaction, error) { return _Erc20.Contract.IncreaseAllowance(&_Erc20.TransactOpts, spender, addedValue) } // Transfer is a paid mutator transaction binding the contract method 0xa9059cbb. // // Solidity: function transfer(address to, uint256 amount) returns(bool) func (_Erc20 *Erc20Transactor) Transfer(opts *bind.TransactOpts, to common.Address, amount *big.Int) (*types.Transaction, error) { return _Erc20.contract.Transact(opts, "transfer", to, amount) } // Transfer is a paid mutator transaction binding the contract method 0xa9059cbb. // // Solidity: function transfer(address to, uint256 amount) returns(bool) func (_Erc20 *Erc20Session) Transfer(to common.Address, amount *big.Int) (*types.Transaction, error) { return _Erc20.Contract.Transfer(&_Erc20.TransactOpts, to, amount) } // Transfer is a paid mutator transaction binding the contract method 0xa9059cbb. // // Solidity: function transfer(address to, uint256 amount) returns(bool) func (_Erc20 *Erc20TransactorSession) Transfer(to common.Address, amount *big.Int) (*types.Transaction, error) { return _Erc20.Contract.Transfer(&_Erc20.TransactOpts, to, amount) } // TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd. // // Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool) func (_Erc20 *Erc20Transactor) TransferFrom(opts *bind.TransactOpts, from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) { return _Erc20.contract.Transact(opts, "transferFrom", from, to, amount) } // TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd. // // Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool) func (_Erc20 *Erc20Session) TransferFrom(from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) { return _Erc20.Contract.TransferFrom(&_Erc20.TransactOpts, from, to, amount) } // TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd. // // Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool) func (_Erc20 *Erc20TransactorSession) TransferFrom(from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) { return _Erc20.Contract.TransferFrom(&_Erc20.TransactOpts, from, to, amount) } // Erc20ApprovalIterator is returned from FilterApproval and is used to iterate over the raw logs and unpacked data for Approval events raised by the Erc20 contract. type Erc20ApprovalIterator struct { Event *Erc20Approval // Event containing the contract specifics and raw log contract *bind.BoundContract // Generic contract to use for unpacking event data event string // Event name to use for unpacking event data logs chan types.Log // Log channel receiving the found contract events sub ethereum.Subscription // Subscription for errors, completion and termination done bool // Whether the subscription completed delivering logs fail error // Occurred error to stop iteration } // Next advances the iterator to the subsequent event, returning whether there // are any more events found. In case of a retrieval or parsing error, false is // returned and Error() can be queried for the exact failure. func (it *Erc20ApprovalIterator) Next() bool { // If the iterator failed, stop iterating if it.fail != nil { return false } // If the iterator completed, deliver directly whatever's available if it.done { select { case log := <-it.logs: it.Event = new(Erc20Approval) if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil { it.fail = err return false } it.Event.Raw = log return true default: return false } } // Iterator still in progress, wait for either a data or an error event select { case log := <-it.logs: it.Event = new(Erc20Approval) if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil { it.fail = err return false } it.Event.Raw = log return true case err := <-it.sub.Err(): it.done = true it.fail = err return it.Next() } } // Error returns any retrieval or parsing error occurred during filtering. func (it *Erc20ApprovalIterator) Error() error { return it.fail } // Close terminates the iteration process, releasing any pending underlying // resources. func (it *Erc20ApprovalIterator) Close() error { it.sub.Unsubscribe() return nil } // Erc20Approval represents a Approval event raised by the Erc20 contract. type Erc20Approval struct { Owner common.Address Spender common.Address Value *big.Int Raw types.Log // Blockchain specific contextual infos } // FilterApproval is a free log retrieval operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925. // // Solidity: event Approval(address indexed owner, address indexed spender, uint256 value) func (_Erc20 *Erc20Filterer) FilterApproval(opts *bind.FilterOpts, owner []common.Address, spender []common.Address) (*Erc20ApprovalIterator, error) { var ownerRule []interface{} for _, ownerItem := range owner { ownerRule = append(ownerRule, ownerItem) } var spenderRule []interface{} for _, spenderItem := range spender { spenderRule = append(spenderRule, spenderItem) } logs, sub, err := _Erc20.contract.FilterLogs(opts, "Approval", ownerRule, spenderRule) if err != nil { return nil, err } return &Erc20ApprovalIterator{contract: _Erc20.contract, event: "Approval", logs: logs, sub: sub}, nil } // WatchApproval is a free log subscription operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925. // // Solidity: event Approval(address indexed owner, address indexed spender, uint256 value) func (_Erc20 *Erc20Filterer) WatchApproval(opts *bind.WatchOpts, sink chan<- *Erc20Approval, owner []common.Address, spender []common.Address) (event.Subscription, error) { var ownerRule []interface{} for _, ownerItem := range owner { ownerRule = append(ownerRule, ownerItem) } var spenderRule []interface{} for _, spenderItem := range spender { spenderRule = append(spenderRule, spenderItem) } logs, sub, err := _Erc20.contract.WatchLogs(opts, "Approval", ownerRule, spenderRule) if err != nil { return nil, err } return event.NewSubscription(func(quit <-chan struct{}) error { defer sub.Unsubscribe() for { select { case log := <-logs: // New log arrived, parse the event and forward to the user event := new(Erc20Approval) if err := _Erc20.contract.UnpackLog(event, "Approval", log); err != nil { return err } event.Raw = log select { case sink <- event: case err := <-sub.Err(): return err case <-quit: return nil } case err := <-sub.Err(): return err case <-quit: return nil } } }), nil } // ParseApproval is a log parse operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925. // // Solidity: event Approval(address indexed owner, address indexed spender, uint256 value) func (_Erc20 *Erc20Filterer) ParseApproval(log types.Log) (*Erc20Approval, error) { event := new(Erc20Approval) if err := _Erc20.contract.UnpackLog(event, "Approval", log); err != nil { return nil, err } event.Raw = log return event, nil } // Erc20TransferIterator is returned from FilterTransfer and is used to iterate over the raw logs and unpacked data for Transfer events raised by the Erc20 contract. type Erc20TransferIterator struct { Event *Erc20Transfer // Event containing the contract specifics and raw log contract *bind.BoundContract // Generic contract to use for unpacking event data event string // Event name to use for unpacking event data logs chan types.Log // Log channel receiving the found contract events sub ethereum.Subscription // Subscription for errors, completion and termination done bool // Whether the subscription completed delivering logs fail error // Occurred error to stop iteration } // Next advances the iterator to the subsequent event, returning whether there // are any more events found. In case of a retrieval or parsing error, false is // returned and Error() can be queried for the exact failure. func (it *Erc20TransferIterator) Next() bool { // If the iterator failed, stop iterating if it.fail != nil { return false } // If the iterator completed, deliver directly whatever's available if it.done { select { case log := <-it.logs: it.Event = new(Erc20Transfer) if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil { it.fail = err return false } it.Event.Raw = log return true default: return false } } // Iterator still in progress, wait for either a data or an error event select { case log := <-it.logs: it.Event = new(Erc20Transfer) if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil { it.fail = err return false } it.Event.Raw = log return true case err := <-it.sub.Err(): it.done = true it.fail = err return it.Next() } } // Error returns any retrieval or parsing error occurred during filtering. func (it *Erc20TransferIterator) Error() error { return it.fail } // Close terminates the iteration process, releasing any pending underlying // resources. func (it *Erc20TransferIterator) Close() error { it.sub.Unsubscribe() return nil } // Erc20Transfer represents a Transfer event raised by the Erc20 contract. type Erc20Transfer struct { From common.Address To common.Address Value *big.Int Raw types.Log // Blockchain specific contextual infos } // FilterTransfer is a free log retrieval operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef. // // Solidity: event Transfer(address indexed from, address indexed to, uint256 value) func (_Erc20 *Erc20Filterer) FilterTransfer(opts *bind.FilterOpts, from []common.Address, to []common.Address) (*Erc20TransferIterator, error) { var fromRule []interface{} for _, fromItem := range from { fromRule = append(fromRule, fromItem) } var toRule []interface{} for _, toItem := range to { toRule = append(toRule, toItem) } logs, sub, err := _Erc20.contract.FilterLogs(opts, "Transfer", fromRule, toRule) if err != nil { return nil, err } return &Erc20TransferIterator{contract: _Erc20.contract, event: "Transfer", logs: logs, sub: sub}, nil } // WatchTransfer is a free log subscription operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef. // // Solidity: event Transfer(address indexed from, address indexed to, uint256 value) func (_Erc20 *Erc20Filterer) WatchTransfer(opts *bind.WatchOpts, sink chan<- *Erc20Transfer, from []common.Address, to []common.Address) (event.Subscription, error) { var fromRule []interface{} for _, fromItem := range from { fromRule = append(fromRule, fromItem) } var toRule []interface{} for _, toItem := range to { toRule = append(toRule, toItem) } logs, sub, err := _Erc20.contract.WatchLogs(opts, "Transfer", fromRule, toRule) if err != nil { return nil, err } return event.NewSubscription(func(quit <-chan struct{}) error { defer sub.Unsubscribe() for { select { case log := <-logs: // New log arrived, parse the event and forward to the user event := new(Erc20Transfer) if err := _Erc20.contract.UnpackLog(event, "Transfer", log); err != nil { return err } event.Raw = log select { case sink <- event: case err := <-sub.Err(): return err case <-quit: return nil } case err := <-sub.Err(): return err case <-quit: return nil } } }), nil } // ParseTransfer is a log parse operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef. // // Solidity: event Transfer(address indexed from, address indexed to, uint256 value) func (_Erc20 *Erc20Filterer) ParseTransfer(log types.Log) (*Erc20Transfer, error) { event := new(Erc20Transfer) if err := _Erc20.contract.UnpackLog(event, "Transfer", log); err != nil { return nil, err } event.Raw = log return event, nil }
```

# contracts/icyBtcSwap/icyBtcSwap.abi

```abi
[{"inputs":[{"internalType":"address","name":"_icy","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"user","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"icyAmount","type":"uint256"},{"indexed":false,"internalType":"string","name":"btcAddress","type":"string"},{"indexed":false,"internalType":"uint256","name":"btcAmount","type":"uint256"}],"name":"RevertIcy","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"signerAddress","type":"address"}],"name":"SetSigner","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"icyAmount","type":"uint256"},{"indexed":false,"internalType":"string","name":"btcAddress","type":"string"},{"indexed":false,"internalType":"uint256","name":"btcAmount","type":"uint256"}],"name":"Swap","type":"event"},{"stateMutability":"nonpayable","type":"fallback"},{"inputs":[],"name":"REVERT_ICY_HASH","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"SWAP_HASH","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"eip712Domain","outputs":[{"internalType":"bytes1","name":"fields","type":"bytes1"},{"internalType":"string","name":"name","type":"string"},{"internalType":"string","name":"version","type":"string"},{"internalType":"uint256","name":"chainId","type":"uint256"},{"internalType":"address","name":"verifyingContract","type":"address"},{"internalType":"bytes32","name":"salt","type":"bytes32"},{"internalType":"uint256[]","name":"extensions","type":"uint256[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"icyAmount","type":"uint256"},{"internalType":"string","name":"btcAddress","type":"string"},{"internalType":"uint256","name":"btcAmount","type":"uint256"},{"internalType":"uint256","name":"nonce","type":"uint256"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"getRevertIcyHash","outputs":[{"internalType":"bytes32","name":"hash","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"_digest","type":"bytes32"},{"internalType":"bytes","name":"_signature","type":"bytes"}],"name":"getSigner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"icyAmount","type":"uint256"},{"internalType":"string","name":"btcAddress","type":"string"},{"internalType":"uint256","name":"btcAmount","type":"uint256"},{"internalType":"uint256","name":"nonce","type":"uint256"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"getSwapHash","outputs":[{"internalType":"bytes32","name":"hash","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"icy","outputs":[{"internalType":"contract ERC20","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"icyAmount","type":"uint256"},{"internalType":"string","name":"btcAddress","type":"string"},{"internalType":"uint256","name":"btcAmount","type":"uint256"},{"internalType":"uint256","name":"nonce","type":"uint256"},{"internalType":"uint256","name":"deadline","type":"uint256"},{"internalType":"bytes","name":"_signature","type":"bytes"}],"name":"revertIcy","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"name":"revertedIcyHashes","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_signerAddress","type":"address"}],"name":"setSigner","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"signerAddress","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"icyAmount","type":"uint256"},{"internalType":"string","name":"btcAddress","type":"string"},{"internalType":"uint256","name":"btcAmount","type":"uint256"},{"internalType":"uint256","name":"nonce","type":"uint256"},{"internalType":"uint256","name":"deadline","type":"uint256"},{"internalType":"bytes","name":"_signature","type":"bytes"}],"name":"swap","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"name":"swappedHashes","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"stateMutability":"payable","type":"receive"}]
```

# contracts/icyBtcSwap/icyBtcSwap.go

```go
// Code generated - DO NOT EDIT. // This file is a generated binding and any manual changes will be lost. package icyBtcSwap import ( "errors" "math/big" "strings" ethereum "github.com/ethereum/go-ethereum" "github.com/ethereum/go-ethereum/accounts/abi" "github.com/ethereum/go-ethereum/accounts/abi/bind" "github.com/ethereum/go-ethereum/common" "github.com/ethereum/go-ethereum/core/types" "github.com/ethereum/go-ethereum/event" ) // Reference imports to suppress errors if they are not otherwise used. var ( _ = errors.New _ = big.NewInt _ = strings.NewReader _ = ethereum.NotFound _ = bind.Bind _ = common.Big1 _ = types.BloomLookup _ = event.NewSubscription _ = abi.ConvertType ) // IcyBtcSwapMetaData contains all meta data concerning the IcyBtcSwap contract. var IcyBtcSwapMetaData = &bind.MetaData{ ABI: "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_icy\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"icyAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"btcAddress\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"btcAmount\",\"type\":\"uint256\"}],\"name\":\"RevertIcy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"signerAddress\",\"type\":\"address\"}],\"name\":\"SetSigner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"icyAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"btcAddress\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"btcAmount\",\"type\":\"uint256\"}],\"name\":\"Swap\",\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"REVERT_ICY_HASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SWAP_HASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"eip712Domain\",\"outputs\":[{\"internalType\":\"bytes1\",\"name\":\"fields\",\"type\":\"bytes1\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"verifyingContract\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"uint256[]\",\"name\":\"extensions\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"icyAmount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"btcAddress\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"btcAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"getRevertIcyHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_digest\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"getSigner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"icyAmount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"btcAddress\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"btcAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"getSwapHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"icy\",\"outputs\":[{\"internalType\":\"contractERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"icyAmount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"btcAddress\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"btcAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"revertIcy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"revertedIcyHashes\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_signerAddress\",\"type\":\"address\"}],\"name\":\"setSigner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"signerAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"icyAmount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"btcAddress\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"btcAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"swap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"swappedHashes\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", } // IcyBtcSwapABI is the input ABI used to generate the binding from. // Deprecated: Use IcyBtcSwapMetaData.ABI instead. var IcyBtcSwapABI = IcyBtcSwapMetaData.ABI // IcyBtcSwap is an auto generated Go binding around an Ethereum contract. type IcyBtcSwap struct { IcyBtcSwapCaller // Read-only binding to the contract IcyBtcSwapTransactor // Write-only binding to the contract IcyBtcSwapFilterer // Log filterer for contract events } // IcyBtcSwapCaller is an auto generated read-only Go binding around an Ethereum contract. type IcyBtcSwapCaller struct { contract *bind.BoundContract // Generic contract wrapper for the low level calls } // IcyBtcSwapTransactor is an auto generated write-only Go binding around an Ethereum contract. type IcyBtcSwapTransactor struct { contract *bind.BoundContract // Generic contract wrapper for the low level calls } // IcyBtcSwapFilterer is an auto generated log filtering Go binding around an Ethereum contract events. type IcyBtcSwapFilterer struct { contract *bind.BoundContract // Generic contract wrapper for the low level calls } // IcyBtcSwapSession is an auto generated Go binding around an Ethereum contract, // with pre-set call and transact options. type IcyBtcSwapSession struct { Contract *IcyBtcSwap // Generic contract binding to set the session for CallOpts bind.CallOpts // Call options to use throughout this session TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session } // IcyBtcSwapCallerSession is an auto generated read-only Go binding around an Ethereum contract, // with pre-set call options. type IcyBtcSwapCallerSession struct { Contract *IcyBtcSwapCaller // Generic contract caller binding to set the session for CallOpts bind.CallOpts // Call options to use throughout this session } // IcyBtcSwapTransactorSession is an auto generated write-only Go binding around an Ethereum contract, // with pre-set transact options. type IcyBtcSwapTransactorSession struct { Contract *IcyBtcSwapTransactor // Generic contract transactor binding to set the session for TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session } // IcyBtcSwapRaw is an auto generated low-level Go binding around an Ethereum contract. type IcyBtcSwapRaw struct { Contract *IcyBtcSwap // Generic contract binding to access the raw methods on } // IcyBtcSwapCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract. type IcyBtcSwapCallerRaw struct { Contract *IcyBtcSwapCaller // Generic read-only contract binding to access the raw methods on } // IcyBtcSwapTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract. type IcyBtcSwapTransactorRaw struct { Contract *IcyBtcSwapTransactor // Generic write-only contract binding to access the raw methods on } // NewIcyBtcSwap creates a new instance of IcyBtcSwap, bound to a specific deployed contract. func NewIcyBtcSwap(address common.Address, backend bind.ContractBackend) (*IcyBtcSwap, error) { contract, err := bindIcyBtcSwap(address, backend, backend, backend) if err != nil { return nil, err } return &IcyBtcSwap{IcyBtcSwapCaller: IcyBtcSwapCaller{contract: contract}, IcyBtcSwapTransactor: IcyBtcSwapTransactor{contract: contract}, IcyBtcSwapFilterer: IcyBtcSwapFilterer{contract: contract}}, nil } // NewIcyBtcSwapCaller creates a new read-only instance of IcyBtcSwap, bound to a specific deployed contract. func NewIcyBtcSwapCaller(address common.Address, caller bind.ContractCaller) (*IcyBtcSwapCaller, error) { contract, err := bindIcyBtcSwap(address, caller, nil, nil) if err != nil { return nil, err } return &IcyBtcSwapCaller{contract: contract}, nil } // NewIcyBtcSwapTransactor creates a new write-only instance of IcyBtcSwap, bound to a specific deployed contract. func NewIcyBtcSwapTransactor(address common.Address, transactor bind.ContractTransactor) (*IcyBtcSwapTransactor, error) { contract, err := bindIcyBtcSwap(address, nil, transactor, nil) if err != nil { return nil, err } return &IcyBtcSwapTransactor{contract: contract}, nil } // NewIcyBtcSwapFilterer creates a new log filterer instance of IcyBtcSwap, bound to a specific deployed contract. func NewIcyBtcSwapFilterer(address common.Address, filterer bind.ContractFilterer) (*IcyBtcSwapFilterer, error) { contract, err := bindIcyBtcSwap(address, nil, nil, filterer) if err != nil { return nil, err } return &IcyBtcSwapFilterer{contract: contract}, nil } // bindIcyBtcSwap binds a generic wrapper to an already deployed contract. func bindIcyBtcSwap(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) { parsed, err := IcyBtcSwapMetaData.GetAbi() if err != nil { return nil, err } return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil } // Call invokes the (constant) contract method with params as input values and // sets the output to result. The result type might be a single field for simple // returns, a slice of interfaces for anonymous returns and a struct for named // returns. func (_IcyBtcSwap *IcyBtcSwapRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error { return _IcyBtcSwap.Contract.IcyBtcSwapCaller.contract.Call(opts, result, method, params...) } // Transfer initiates a plain transaction to move funds to the contract, calling // its default method if one is available. func (_IcyBtcSwap *IcyBtcSwapRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) { return _IcyBtcSwap.Contract.IcyBtcSwapTransactor.contract.Transfer(opts) } // Transact invokes the (paid) contract method with params as input values. func (_IcyBtcSwap *IcyBtcSwapRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) { return _IcyBtcSwap.Contract.IcyBtcSwapTransactor.contract.Transact(opts, method, params...) } // Call invokes the (constant) contract method with params as input values and // sets the output to result. The result type might be a single field for simple // returns, a slice of interfaces for anonymous returns and a struct for named // returns. func (_IcyBtcSwap *IcyBtcSwapCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error { return _IcyBtcSwap.Contract.contract.Call(opts, result, method, params...) } // Transfer initiates a plain transaction to move funds to the contract, calling // its default method if one is available. func (_IcyBtcSwap *IcyBtcSwapTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) { return _IcyBtcSwap.Contract.contract.Transfer(opts) } // Transact invokes the (paid) contract method with params as input values. func (_IcyBtcSwap *IcyBtcSwapTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) { return _IcyBtcSwap.Contract.contract.Transact(opts, method, params...) } // REVERTICYHASH is a free data retrieval call binding the contract method 0x2d6d3d01. // // Solidity: function REVERT_ICY_HASH() view returns(bytes32) func (_IcyBtcSwap *IcyBtcSwapCaller) REVERTICYHASH(opts *bind.CallOpts) ([32]byte, error) { var out []interface{} err := _IcyBtcSwap.contract.Call(opts, &out, "REVERT_ICY_HASH") if err != nil { return *new([32]byte), err } out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte) return out0, err } // REVERTICYHASH is a free data retrieval call binding the contract method 0x2d6d3d01. // // Solidity: function REVERT_ICY_HASH() view returns(bytes32) func (_IcyBtcSwap *IcyBtcSwapSession) REVERTICYHASH() ([32]byte, error) { return _IcyBtcSwap.Contract.REVERTICYHASH(&_IcyBtcSwap.CallOpts) } // REVERTICYHASH is a free data retrieval call binding the contract method 0x2d6d3d01. // // Solidity: function REVERT_ICY_HASH() view returns(bytes32) func (_IcyBtcSwap *IcyBtcSwapCallerSession) REVERTICYHASH() ([32]byte, error) { return _IcyBtcSwap.Contract.REVERTICYHASH(&_IcyBtcSwap.CallOpts) } // SWAPHASH is a free data retrieval call binding the contract method 0x30c8b3da. // // Solidity: function SWAP_HASH() view returns(bytes32) func (_IcyBtcSwap *IcyBtcSwapCaller) SWAPHASH(opts *bind.CallOpts) ([32]byte, error) { var out []interface{} err := _IcyBtcSwap.contract.Call(opts, &out, "SWAP_HASH") if err != nil { return *new([32]byte), err } out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte) return out0, err } // SWAPHASH is a free data retrieval call binding the contract method 0x30c8b3da. // // Solidity: function SWAP_HASH() view returns(bytes32) func (_IcyBtcSwap *IcyBtcSwapSession) SWAPHASH() ([32]byte, error) { return _IcyBtcSwap.Contract.SWAPHASH(&_IcyBtcSwap.CallOpts) } // SWAPHASH is a free data retrieval call binding the contract method 0x30c8b3da. // // Solidity: function SWAP_HASH() view returns(bytes32) func (_IcyBtcSwap *IcyBtcSwapCallerSession) SWAPHASH() ([32]byte, error) { return _IcyBtcSwap.Contract.SWAPHASH(&_IcyBtcSwap.CallOpts) } // Eip712Domain is a free data retrieval call binding the contract method 0x84b0196e. // // Solidity: function eip712Domain() view returns(bytes1 fields, string name, string version, uint256 chainId, address verifyingContract, bytes32 salt, uint256[] extensions) func (_IcyBtcSwap *IcyBtcSwapCaller) Eip712Domain(opts *bind.CallOpts) (struct { Fields [1]byte Name string Version string ChainId *big.Int VerifyingContract common.Address Salt [32]byte Extensions []*big.Int }, error) { var out []interface{} err := _IcyBtcSwap.contract.Call(opts, &out, "eip712Domain") outstruct := new(struct { Fields [1]byte Name string Version string ChainId *big.Int VerifyingContract common.Address Salt [32]byte Extensions []*big.Int }) if err != nil { return *outstruct, err } outstruct.Fields = *abi.ConvertType(out[0], new([1]byte)).(*[1]byte) outstruct.Name = *abi.ConvertType(out[1], new(string)).(*string) outstruct.Version = *abi.ConvertType(out[2], new(string)).(*string) outstruct.ChainId = *abi.ConvertType(out[3], new(*big.Int)).(**big.Int) outstruct.VerifyingContract = *abi.ConvertType(out[4], new(common.Address)).(*common.Address) outstruct.Salt = *abi.ConvertType(out[5], new([32]byte)).(*[32]byte) outstruct.Extensions = *abi.ConvertType(out[6], new([]*big.Int)).(*[]*big.Int) return *outstruct, err } // Eip712Domain is a free data retrieval call binding the contract method 0x84b0196e. // // Solidity: function eip712Domain() view returns(bytes1 fields, string name, string version, uint256 chainId, address verifyingContract, bytes32 salt, uint256[] extensions) func (_IcyBtcSwap *IcyBtcSwapSession) Eip712Domain() (struct { Fields [1]byte Name string Version string ChainId *big.Int VerifyingContract common.Address Salt [32]byte Extensions []*big.Int }, error) { return _IcyBtcSwap.Contract.Eip712Domain(&_IcyBtcSwap.CallOpts) } // Eip712Domain is a free data retrieval call binding the contract method 0x84b0196e. // // Solidity: function eip712Domain() view returns(bytes1 fields, string name, string version, uint256 chainId, address verifyingContract, bytes32 salt, uint256[] extensions) func (_IcyBtcSwap *IcyBtcSwapCallerSession) Eip712Domain() (struct { Fields [1]byte Name string Version string ChainId *big.Int VerifyingContract common.Address Salt [32]byte Extensions []*big.Int }, error) { return _IcyBtcSwap.Contract.Eip712Domain(&_IcyBtcSwap.CallOpts) } // GetRevertIcyHash is a free data retrieval call binding the contract method 0x32ce558d. // // Solidity: function getRevertIcyHash(uint256 icyAmount, string btcAddress, uint256 btcAmount, uint256 nonce, uint256 deadline) view returns(bytes32 hash) func (_IcyBtcSwap *IcyBtcSwapCaller) GetRevertIcyHash(opts *bind.CallOpts, icyAmount *big.Int, btcAddress string, btcAmount *big.Int, nonce *big.Int, deadline *big.Int) ([32]byte, error) { var out []interface{} err := _IcyBtcSwap.contract.Call(opts, &out, "getRevertIcyHash", icyAmount, btcAddress, btcAmount, nonce, deadline) if err != nil { return *new([32]byte), err } out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte) return out0, err } // GetRevertIcyHash is a free data retrieval call binding the contract method 0x32ce558d. // // Solidity: function getRevertIcyHash(uint256 icyAmount, string btcAddress, uint256 btcAmount, uint256 nonce, uint256 deadline) view returns(bytes32 hash) func (_IcyBtcSwap *IcyBtcSwapSession) GetRevertIcyHash(icyAmount *big.Int, btcAddress string, btcAmount *big.Int, nonce *big.Int, deadline *big.Int) ([32]byte, error) { return _IcyBtcSwap.Contract.GetRevertIcyHash(&_IcyBtcSwap.CallOpts, icyAmount, btcAddress, btcAmount, nonce, deadline) } // GetRevertIcyHash is a free data retrieval call binding the contract method 0x32ce558d. // // Solidity: function getRevertIcyHash(uint256 icyAmount, string btcAddress, uint256 btcAmount, uint256 nonce, uint256 deadline) view returns(bytes32 hash) func (_IcyBtcSwap *IcyBtcSwapCallerSession) GetRevertIcyHash(icyAmount *big.Int, btcAddress string, btcAmount *big.Int, nonce *big.Int, deadline *big.Int) ([32]byte, error) { return _IcyBtcSwap.Contract.GetRevertIcyHash(&_IcyBtcSwap.CallOpts, icyAmount, btcAddress, btcAmount, nonce, deadline) } // GetSigner is a free data retrieval call binding the contract method 0xf7b2ec0d. // // Solidity: function getSigner(bytes32 _digest, bytes _signature) view returns(address) func (_IcyBtcSwap *IcyBtcSwapCaller) GetSigner(opts *bind.CallOpts, _digest [32]byte, _signature []byte) (common.Address, error) { var out []interface{} err := _IcyBtcSwap.contract.Call(opts, &out, "getSigner", _digest, _signature) if err != nil { return *new(common.Address), err } out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address) return out0, err } // GetSigner is a free data retrieval call binding the contract method 0xf7b2ec0d. // // Solidity: function getSigner(bytes32 _digest, bytes _signature) view returns(address) func (_IcyBtcSwap *IcyBtcSwapSession) GetSigner(_digest [32]byte, _signature []byte) (common.Address, error) { return _IcyBtcSwap.Contract.GetSigner(&_IcyBtcSwap.CallOpts, _digest, _signature) } // GetSigner is a free data retrieval call binding the contract method 0xf7b2ec0d. // // Solidity: function getSigner(bytes32 _digest, bytes _signature) view returns(address) func (_IcyBtcSwap *IcyBtcSwapCallerSession) GetSigner(_digest [32]byte, _signature []byte) (common.Address, error) { return _IcyBtcSwap.Contract.GetSigner(&_IcyBtcSwap.CallOpts, _digest, _signature) } // GetSwapHash is a free data retrieval call binding the contract method 0x6327a9d0. // // Solidity: function getSwapHash(uint256 icyAmount, string btcAddress, uint256 btcAmount, uint256 nonce, uint256 deadline) view returns(bytes32 hash) func (_IcyBtcSwap *IcyBtcSwapCaller) GetSwapHash(opts *bind.CallOpts, icyAmount *big.Int, btcAddress string, btcAmount *big.Int, nonce *big.Int, deadline *big.Int) ([32]byte, error) { var out []interface{} err := _IcyBtcSwap.contract.Call(opts, &out, "getSwapHash", icyAmount, btcAddress, btcAmount, nonce, deadline) if err != nil { return *new([32]byte), err } out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte) return out0, err } // GetSwapHash is a free data retrieval call binding the contract method 0x6327a9d0. // // Solidity: function getSwapHash(uint256 icyAmount, string btcAddress, uint256 btcAmount, uint256 nonce, uint256 deadline) view returns(bytes32 hash) func (_IcyBtcSwap *IcyBtcSwapSession) GetSwapHash(icyAmount *big.Int, btcAddress string, btcAmount *big.Int, nonce *big.Int, deadline *big.Int) ([32]byte, error) { return _IcyBtcSwap.Contract.GetSwapHash(&_IcyBtcSwap.CallOpts, icyAmount, btcAddress, btcAmount, nonce, deadline) } // GetSwapHash is a free data retrieval call binding the contract method 0x6327a9d0. // // Solidity: function getSwapHash(uint256 icyAmount, string btcAddress, uint256 btcAmount, uint256 nonce, uint256 deadline) view returns(bytes32 hash) func (_IcyBtcSwap *IcyBtcSwapCallerSession) GetSwapHash(icyAmount *big.Int, btcAddress string, btcAmount *big.Int, nonce *big.Int, deadline *big.Int) ([32]byte, error) { return _IcyBtcSwap.Contract.GetSwapHash(&_IcyBtcSwap.CallOpts, icyAmount, btcAddress, btcAmount, nonce, deadline) } // Icy is a free data retrieval call binding the contract method 0x7f245ab1. // // Solidity: function icy() view returns(address) func (_IcyBtcSwap *IcyBtcSwapCaller) Icy(opts *bind.CallOpts) (common.Address, error) { var out []interface{} err := _IcyBtcSwap.contract.Call(opts, &out, "icy") if err != nil { return *new(common.Address), err } out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address) return out0, err } // Icy is a free data retrieval call binding the contract method 0x7f245ab1. // // Solidity: function icy() view returns(address) func (_IcyBtcSwap *IcyBtcSwapSession) Icy() (common.Address, error) { return _IcyBtcSwap.Contract.Icy(&_IcyBtcSwap.CallOpts) } // Icy is a free data retrieval call binding the contract method 0x7f245ab1. // // Solidity: function icy() view returns(address) func (_IcyBtcSwap *IcyBtcSwapCallerSession) Icy() (common.Address, error) { return _IcyBtcSwap.Contract.Icy(&_IcyBtcSwap.CallOpts) } // Owner is a free data retrieval call binding the contract method 0x8da5cb5b. // // Solidity: function owner() view returns(address) func (_IcyBtcSwap *IcyBtcSwapCaller) Owner(opts *bind.CallOpts) (common.Address, error) { var out []interface{} err := _IcyBtcSwap.contract.Call(opts, &out, "owner") if err != nil { return *new(common.Address), err } out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address) return out0, err } // Owner is a free data retrieval call binding the contract method 0x8da5cb5b. // // Solidity: function owner() view returns(address) func (_IcyBtcSwap *IcyBtcSwapSession) Owner() (common.Address, error) { return _IcyBtcSwap.Contract.Owner(&_IcyBtcSwap.CallOpts) } // Owner is a free data retrieval call binding the contract method 0x8da5cb5b. // // Solidity: function owner() view returns(address) func (_IcyBtcSwap *IcyBtcSwapCallerSession) Owner() (common.Address, error) { return _IcyBtcSwap.Contract.Owner(&_IcyBtcSwap.CallOpts) } // RevertedIcyHashes is a free data retrieval call binding the contract method 0x3d2b52db. // // Solidity: function revertedIcyHashes(bytes32 ) view returns(bool) func (_IcyBtcSwap *IcyBtcSwapCaller) RevertedIcyHashes(opts *bind.CallOpts, arg0 [32]byte) (bool, error) { var out []interface{} err := _IcyBtcSwap.contract.Call(opts, &out, "revertedIcyHashes", arg0) if err != nil { return *new(bool), err } out0 := *abi.ConvertType(out[0], new(bool)).(*bool) return out0, err } // RevertedIcyHashes is a free data retrieval call binding the contract method 0x3d2b52db. // // Solidity: function revertedIcyHashes(bytes32 ) view returns(bool) func (_IcyBtcSwap *IcyBtcSwapSession) RevertedIcyHashes(arg0 [32]byte) (bool, error) { return _IcyBtcSwap.Contract.RevertedIcyHashes(&_IcyBtcSwap.CallOpts, arg0) } // RevertedIcyHashes is a free data retrieval call binding the contract method 0x3d2b52db. // // Solidity: function revertedIcyHashes(bytes32 ) view returns(bool) func (_IcyBtcSwap *IcyBtcSwapCallerSession) RevertedIcyHashes(arg0 [32]byte) (bool, error) { return _IcyBtcSwap.Contract.RevertedIcyHashes(&_IcyBtcSwap.CallOpts, arg0) } // SignerAddress is a free data retrieval call binding the contract method 0x5b7633d0. // // Solidity: function signerAddress() view returns(address) func (_IcyBtcSwap *IcyBtcSwapCaller) SignerAddress(opts *bind.CallOpts) (common.Address, error) { var out []interface{} err := _IcyBtcSwap.contract.Call(opts, &out, "signerAddress") if err != nil { return *new(common.Address), err } out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address) return out0, err } // SignerAddress is a free data retrieval call binding the contract method 0x5b7633d0. // // Solidity: function signerAddress() view returns(address) func (_IcyBtcSwap *IcyBtcSwapSession) SignerAddress() (common.Address, error) { return _IcyBtcSwap.Contract.SignerAddress(&_IcyBtcSwap.CallOpts) } // SignerAddress is a free data retrieval call binding the contract method 0x5b7633d0. // // Solidity: function signerAddress() view returns(address) func (_IcyBtcSwap *IcyBtcSwapCallerSession) SignerAddress() (common.Address, error) { return _IcyBtcSwap.Contract.SignerAddress(&_IcyBtcSwap.CallOpts) } // SwappedHashes is a free data retrieval call binding the contract method 0x6072e236. // // Solidity: function swappedHashes(bytes32 ) view returns(bool) func (_IcyBtcSwap *IcyBtcSwapCaller) SwappedHashes(opts *bind.CallOpts, arg0 [32]byte) (bool, error) { var out []interface{} err := _IcyBtcSwap.contract.Call(opts, &out, "swappedHashes", arg0) if err != nil { return *new(bool), err } out0 := *abi.ConvertType(out[0], new(bool)).(*bool) return out0, err } // SwappedHashes is a free data retrieval call binding the contract method 0x6072e236. // // Solidity: function swappedHashes(bytes32 ) view returns(bool) func (_IcyBtcSwap *IcyBtcSwapSession) SwappedHashes(arg0 [32]byte) (bool, error) { return _IcyBtcSwap.Contract.SwappedHashes(&_IcyBtcSwap.CallOpts, arg0) } // SwappedHashes is a free data retrieval call binding the contract method 0x6072e236. // // Solidity: function swappedHashes(bytes32 ) view returns(bool) func (_IcyBtcSwap *IcyBtcSwapCallerSession) SwappedHashes(arg0 [32]byte) (bool, error) { return _IcyBtcSwap.Contract.SwappedHashes(&_IcyBtcSwap.CallOpts, arg0) } // RevertIcy is a paid mutator transaction binding the contract method 0x666f5a65. // // Solidity: function revertIcy(uint256 icyAmount, string btcAddress, uint256 btcAmount, uint256 nonce, uint256 deadline, bytes _signature) returns() func (_IcyBtcSwap *IcyBtcSwapTransactor) RevertIcy(opts *bind.TransactOpts, icyAmount *big.Int, btcAddress string, btcAmount *big.Int, nonce *big.Int, deadline *big.Int, _signature []byte) (*types.Transaction, error) { return _IcyBtcSwap.contract.Transact(opts, "revertIcy", icyAmount, btcAddress, btcAmount, nonce, deadline, _signature) } // RevertIcy is a paid mutator transaction binding the contract method 0x666f5a65. // // Solidity: function revertIcy(uint256 icyAmount, string btcAddress, uint256 btcAmount, uint256 nonce, uint256 deadline, bytes _signature) returns() func (_IcyBtcSwap *IcyBtcSwapSession) RevertIcy(icyAmount *big.Int, btcAddress string, btcAmount *big.Int, nonce *big.Int, deadline *big.Int, _signature []byte) (*types.Transaction, error) { return _IcyBtcSwap.Contract.RevertIcy(&_IcyBtcSwap.TransactOpts, icyAmount, btcAddress, btcAmount, nonce, deadline, _signature) } // RevertIcy is a paid mutator transaction binding the contract method 0x666f5a65. // // Solidity: function revertIcy(uint256 icyAmount, string btcAddress, uint256 btcAmount, uint256 nonce, uint256 deadline, bytes _signature) returns() func (_IcyBtcSwap *IcyBtcSwapTransactorSession) RevertIcy(icyAmount *big.Int, btcAddress string, btcAmount *big.Int, nonce *big.Int, deadline *big.Int, _signature []byte) (*types.Transaction, error) { return _IcyBtcSwap.Contract.RevertIcy(&_IcyBtcSwap.TransactOpts, icyAmount, btcAddress, btcAmount, nonce, deadline, _signature) } // SetSigner is a paid mutator transaction binding the contract method 0x6c19e783. // // Solidity: function setSigner(address _signerAddress) returns() func (_IcyBtcSwap *IcyBtcSwapTransactor) SetSigner(opts *bind.TransactOpts, _signerAddress common.Address) (*types.Transaction, error) { return _IcyBtcSwap.contract.Transact(opts, "setSigner", _signerAddress) } // SetSigner is a paid mutator transaction binding the contract method 0x6c19e783. // // Solidity: function setSigner(address _signerAddress) returns() func (_IcyBtcSwap *IcyBtcSwapSession) SetSigner(_signerAddress common.Address) (*types.Transaction, error) { return _IcyBtcSwap.Contract.SetSigner(&_IcyBtcSwap.TransactOpts, _signerAddress) } // SetSigner is a paid mutator transaction binding the contract method 0x6c19e783. // // Solidity: function setSigner(address _signerAddress) returns() func (_IcyBtcSwap *IcyBtcSwapTransactorSession) SetSigner(_signerAddress common.Address) (*types.Transaction, error) { return _IcyBtcSwap.Contract.SetSigner(&_IcyBtcSwap.TransactOpts, _signerAddress) } // Swap is a paid mutator transaction binding the contract method 0xade44138. // // Solidity: function swap(uint256 icyAmount, string btcAddress, uint256 btcAmount, uint256 nonce, uint256 deadline, bytes _signature) returns() func (_IcyBtcSwap *IcyBtcSwapTransactor) Swap(opts *bind.TransactOpts, icyAmount *big.Int, btcAddress string, btcAmount *big.Int, nonce *big.Int, deadline *big.Int, _signature []byte) (*types.Transaction, error) { return _IcyBtcSwap.contract.Transact(opts, "swap", icyAmount, btcAddress, btcAmount, nonce, deadline, _signature) } // Swap is a paid mutator transaction binding the contract method 0xade44138. // // Solidity: function swap(uint256 icyAmount, string btcAddress, uint256 btcAmount, uint256 nonce, uint256 deadline, bytes _signature) returns() func (_IcyBtcSwap *IcyBtcSwapSession) Swap(icyAmount *big.Int, btcAddress string, btcAmount *big.Int, nonce *big.Int, deadline *big.Int, _signature []byte) (*types.Transaction, error) { return _IcyBtcSwap.Contract.Swap(&_IcyBtcSwap.TransactOpts, icyAmount, btcAddress, btcAmount, nonce, deadline, _signature) } // Swap is a paid mutator transaction binding the contract method 0xade44138. // // Solidity: function swap(uint256 icyAmount, string btcAddress, uint256 btcAmount, uint256 nonce, uint256 deadline, bytes _signature) returns() func (_IcyBtcSwap *IcyBtcSwapTransactorSession) Swap(icyAmount *big.Int, btcAddress string, btcAmount *big.Int, nonce *big.Int, deadline *big.Int, _signature []byte) (*types.Transaction, error) { return _IcyBtcSwap.Contract.Swap(&_IcyBtcSwap.TransactOpts, icyAmount, btcAddress, btcAmount, nonce, deadline, _signature) } // TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b. // // Solidity: function transferOwnership(address newOwner) returns() func (_IcyBtcSwap *IcyBtcSwapTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) { return _IcyBtcSwap.contract.Transact(opts, "transferOwnership", newOwner) } // TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b. // // Solidity: function transferOwnership(address newOwner) returns() func (_IcyBtcSwap *IcyBtcSwapSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) { return _IcyBtcSwap.Contract.TransferOwnership(&_IcyBtcSwap.TransactOpts, newOwner) } // TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b. // // Solidity: function transferOwnership(address newOwner) returns() func (_IcyBtcSwap *IcyBtcSwapTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) { return _IcyBtcSwap.Contract.TransferOwnership(&_IcyBtcSwap.TransactOpts, newOwner) } // Fallback is a paid mutator transaction binding the contract fallback function. // // Solidity: fallback() returns() func (_IcyBtcSwap *IcyBtcSwapTransactor) Fallback(opts *bind.TransactOpts, calldata []byte) (*types.Transaction, error) { return _IcyBtcSwap.contract.RawTransact(opts, calldata) } // Fallback is a paid mutator transaction binding the contract fallback function. // // Solidity: fallback() returns() func (_IcyBtcSwap *IcyBtcSwapSession) Fallback(calldata []byte) (*types.Transaction, error) { return _IcyBtcSwap.Contract.Fallback(&_IcyBtcSwap.TransactOpts, calldata) } // Fallback is a paid mutator transaction binding the contract fallback function. // // Solidity: fallback() returns() func (_IcyBtcSwap *IcyBtcSwapTransactorSession) Fallback(calldata []byte) (*types.Transaction, error) { return _IcyBtcSwap.Contract.Fallback(&_IcyBtcSwap.TransactOpts, calldata) } // Receive is a paid mutator transaction binding the contract receive function. // // Solidity: receive() payable returns() func (_IcyBtcSwap *IcyBtcSwapTransactor) Receive(opts *bind.TransactOpts) (*types.Transaction, error) { return _IcyBtcSwap.contract.RawTransact(opts, nil) // calldata is disallowed for receive function } // Receive is a paid mutator transaction binding the contract receive function. // // Solidity: receive() payable returns() func (_IcyBtcSwap *IcyBtcSwapSession) Receive() (*types.Transaction, error) { return _IcyBtcSwap.Contract.Receive(&_IcyBtcSwap.TransactOpts) } // Receive is a paid mutator transaction binding the contract receive function. // // Solidity: receive() payable returns() func (_IcyBtcSwap *IcyBtcSwapTransactorSession) Receive() (*types.Transaction, error) { return _IcyBtcSwap.Contract.Receive(&_IcyBtcSwap.TransactOpts) } // IcyBtcSwapOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the IcyBtcSwap contract. type IcyBtcSwapOwnershipTransferredIterator struct { Event *IcyBtcSwapOwnershipTransferred // Event containing the contract specifics and raw log contract *bind.BoundContract // Generic contract to use for unpacking event data event string // Event name to use for unpacking event data logs chan types.Log // Log channel receiving the found contract events sub ethereum.Subscription // Subscription for errors, completion and termination done bool // Whether the subscription completed delivering logs fail error // Occurred error to stop iteration } // Next advances the iterator to the subsequent event, returning whether there // are any more events found. In case of a retrieval or parsing error, false is // returned and Error() can be queried for the exact failure. func (it *IcyBtcSwapOwnershipTransferredIterator) Next() bool { // If the iterator failed, stop iterating if it.fail != nil { return false } // If the iterator completed, deliver directly whatever's available if it.done { select { case log := <-it.logs: it.Event = new(IcyBtcSwapOwnershipTransferred) if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil { it.fail = err return false } it.Event.Raw = log return true default: return false } } // Iterator still in progress, wait for either a data or an error event select { case log := <-it.logs: it.Event = new(IcyBtcSwapOwnershipTransferred) if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil { it.fail = err return false } it.Event.Raw = log return true case err := <-it.sub.Err(): it.done = true it.fail = err return it.Next() } } // Error returns any retrieval or parsing error occurred during filtering. func (it *IcyBtcSwapOwnershipTransferredIterator) Error() error { return it.fail } // Close terminates the iteration process, releasing any pending underlying // resources. func (it *IcyBtcSwapOwnershipTransferredIterator) Close() error { it.sub.Unsubscribe() return nil } // IcyBtcSwapOwnershipTransferred represents a OwnershipTransferred event raised by the IcyBtcSwap contract. type IcyBtcSwapOwnershipTransferred struct { User common.Address NewOwner common.Address Raw types.Log // Blockchain specific contextual infos } // FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0. // // Solidity: event OwnershipTransferred(address indexed user, address indexed newOwner) func (_IcyBtcSwap *IcyBtcSwapFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, user []common.Address, newOwner []common.Address) (*IcyBtcSwapOwnershipTransferredIterator, error) { var userRule []interface{} for _, userItem := range user { userRule = append(userRule, userItem) } var newOwnerRule []interface{} for _, newOwnerItem := range newOwner { newOwnerRule = append(newOwnerRule, newOwnerItem) } logs, sub, err := _IcyBtcSwap.contract.FilterLogs(opts, "OwnershipTransferred", userRule, newOwnerRule) if err != nil { return nil, err } return &IcyBtcSwapOwnershipTransferredIterator{contract: _IcyBtcSwap.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil } // WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0. // // Solidity: event OwnershipTransferred(address indexed user, address indexed newOwner) func (_IcyBtcSwap *IcyBtcSwapFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *IcyBtcSwapOwnershipTransferred, user []common.Address, newOwner []common.Address) (event.Subscription, error) { var userRule []interface{} for _, userItem := range user { userRule = append(userRule, userItem) } var newOwnerRule []interface{} for _, newOwnerItem := range newOwner { newOwnerRule = append(newOwnerRule, newOwnerItem) } logs, sub, err := _IcyBtcSwap.contract.WatchLogs(opts, "OwnershipTransferred", userRule, newOwnerRule) if err != nil { return nil, err } return event.NewSubscription(func(quit <-chan struct{}) error { defer sub.Unsubscribe() for { select { case log := <-logs: // New log arrived, parse the event and forward to the user event := new(IcyBtcSwapOwnershipTransferred) if err := _IcyBtcSwap.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil { return err } event.Raw = log select { case sink <- event: case err := <-sub.Err(): return err case <-quit: return nil } case err := <-sub.Err(): return err case <-quit: return nil } } }), nil } // ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0. // // Solidity: event OwnershipTransferred(address indexed user, address indexed newOwner) func (_IcyBtcSwap *IcyBtcSwapFilterer) ParseOwnershipTransferred(log types.Log) (*IcyBtcSwapOwnershipTransferred, error) { event := new(IcyBtcSwapOwnershipTransferred) if err := _IcyBtcSwap.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil { return nil, err } event.Raw = log return event, nil } // IcyBtcSwapRevertIcyIterator is returned from FilterRevertIcy and is used to iterate over the raw logs and unpacked data for RevertIcy events raised by the IcyBtcSwap contract. type IcyBtcSwapRevertIcyIterator struct { Event *IcyBtcSwapRevertIcy // Event containing the contract specifics and raw log contract *bind.BoundContract // Generic contract to use for unpacking event data event string // Event name to use for unpacking event data logs chan types.Log // Log channel receiving the found contract events sub ethereum.Subscription // Subscription for errors, completion and termination done bool // Whether the subscription completed delivering logs fail error // Occurred error to stop iteration } // Next advances the iterator to the subsequent event, returning whether there // are any more events found. In case of a retrieval or parsing error, false is // returned and Error() can be queried for the exact failure. func (it *IcyBtcSwapRevertIcyIterator) Next() bool { // If the iterator failed, stop iterating if it.fail != nil { return false } // If the iterator completed, deliver directly whatever's available if it.done { select { case log := <-it.logs: it.Event = new(IcyBtcSwapRevertIcy) if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil { it.fail = err return false } it.Event.Raw = log return true default: return false } } // Iterator still in progress, wait for either a data or an error event select { case log := <-it.logs: it.Event = new(IcyBtcSwapRevertIcy) if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil { it.fail = err return false } it.Event.Raw = log return true case err := <-it.sub.Err(): it.done = true it.fail = err return it.Next() } } // Error returns any retrieval or parsing error occurred during filtering. func (it *IcyBtcSwapRevertIcyIterator) Error() error { return it.fail } // Close terminates the iteration process, releasing any pending underlying // resources. func (it *IcyBtcSwapRevertIcyIterator) Close() error { it.sub.Unsubscribe() return nil } // IcyBtcSwapRevertIcy represents a RevertIcy event raised by the IcyBtcSwap contract. type IcyBtcSwapRevertIcy struct { IcyAmount *big.Int BtcAddress string BtcAmount *big.Int Raw types.Log // Blockchain specific contextual infos } // FilterRevertIcy is a free log retrieval operation binding the contract event 0xd65289b780c2a5756f2385450f37835d3af0fd779700af98d868c8f952e9acff. // // Solidity: event RevertIcy(uint256 icyAmount, string btcAddress, uint256 btcAmount) func (_IcyBtcSwap *IcyBtcSwapFilterer) FilterRevertIcy(opts *bind.FilterOpts) (*IcyBtcSwapRevertIcyIterator, error) { logs, sub, err := _IcyBtcSwap.contract.FilterLogs(opts, "RevertIcy") if err != nil { return nil, err } return &IcyBtcSwapRevertIcyIterator{contract: _IcyBtcSwap.contract, event: "RevertIcy", logs: logs, sub: sub}, nil } // WatchRevertIcy is a free log subscription operation binding the contract event 0xd65289b780c2a5756f2385450f37835d3af0fd779700af98d868c8f952e9acff. // // Solidity: event RevertIcy(uint256 icyAmount, string btcAddress, uint256 btcAmount) func (_IcyBtcSwap *IcyBtcSwapFilterer) WatchRevertIcy(opts *bind.WatchOpts, sink chan<- *IcyBtcSwapRevertIcy) (event.Subscription, error) { logs, sub, err := _IcyBtcSwap.contract.WatchLogs(opts, "RevertIcy") if err != nil { return nil, err } return event.NewSubscription(func(quit <-chan struct{}) error { defer sub.Unsubscribe() for { select { case log := <-logs: // New log arrived, parse the event and forward to the user event := new(IcyBtcSwapRevertIcy) if err := _IcyBtcSwap.contract.UnpackLog(event, "RevertIcy", log); err != nil { return err } event.Raw = log select { case sink <- event: case err := <-sub.Err(): return err case <-quit: return nil } case err := <-sub.Err(): return err case <-quit: return nil } } }), nil } // ParseRevertIcy is a log parse operation binding the contract event 0xd65289b780c2a5756f2385450f37835d3af0fd779700af98d868c8f952e9acff. // // Solidity: event RevertIcy(uint256 icyAmount, string btcAddress, uint256 btcAmount) func (_IcyBtcSwap *IcyBtcSwapFilterer) ParseRevertIcy(log types.Log) (*IcyBtcSwapRevertIcy, error) { event := new(IcyBtcSwapRevertIcy) if err := _IcyBtcSwap.contract.UnpackLog(event, "RevertIcy", log); err != nil { return nil, err } event.Raw = log return event, nil } // IcyBtcSwapSetSignerIterator is returned from FilterSetSigner and is used to iterate over the raw logs and unpacked data for SetSigner events raised by the IcyBtcSwap contract. type IcyBtcSwapSetSignerIterator struct { Event *IcyBtcSwapSetSigner // Event containing the contract specifics and raw log contract *bind.BoundContract // Generic contract to use for unpacking event data event string // Event name to use for unpacking event data logs chan types.Log // Log channel receiving the found contract events sub ethereum.Subscription // Subscription for errors, completion and termination done bool // Whether the subscription completed delivering logs fail error // Occurred error to stop iteration } // Next advances the iterator to the subsequent event, returning whether there // are any more events found. In case of a retrieval or parsing error, false is // returned and Error() can be queried for the exact failure. func (it *IcyBtcSwapSetSignerIterator) Next() bool { // If the iterator failed, stop iterating if it.fail != nil { return false } // If the iterator completed, deliver directly whatever's available if it.done { select { case log := <-it.logs: it.Event = new(IcyBtcSwapSetSigner) if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil { it.fail = err return false } it.Event.Raw = log return true default: return false } } // Iterator still in progress, wait for either a data or an error event select { case log := <-it.logs: it.Event = new(IcyBtcSwapSetSigner) if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil { it.fail = err return false } it.Event.Raw = log return true case err := <-it.sub.Err(): it.done = true it.fail = err return it.Next() } } // Error returns any retrieval or parsing error occurred during filtering. func (it *IcyBtcSwapSetSignerIterator) Error() error { return it.fail } // Close terminates the iteration process, releasing any pending underlying // resources. func (it *IcyBtcSwapSetSignerIterator) Close() error { it.sub.Unsubscribe() return nil } // IcyBtcSwapSetSigner represents a SetSigner event raised by the IcyBtcSwap contract. type IcyBtcSwapSetSigner struct { SignerAddress common.Address Raw types.Log // Blockchain specific contextual infos } // FilterSetSigner is a free log retrieval operation binding the contract event 0xbb10aee7ef5a307b8097c6a7f2892b909ff1736fd24a6a5260640c185f7153b6. // // Solidity: event SetSigner(address signerAddress) func (_IcyBtcSwap *IcyBtcSwapFilterer) FilterSetSigner(opts *bind.FilterOpts) (*IcyBtcSwapSetSignerIterator, error) { logs, sub, err := _IcyBtcSwap.contract.FilterLogs(opts, "SetSigner") if err != nil { return nil, err } return &IcyBtcSwapSetSignerIterator{contract: _IcyBtcSwap.contract, event: "SetSigner", logs: logs, sub: sub}, nil } // WatchSetSigner is a free log subscription operation binding the contract event 0xbb10aee7ef5a307b8097c6a7f2892b909ff1736fd24a6a5260640c185f7153b6. // // Solidity: event SetSigner(address signerAddress) func (_IcyBtcSwap *IcyBtcSwapFilterer) WatchSetSigner(opts *bind.WatchOpts, sink chan<- *IcyBtcSwapSetSigner) (event.Subscription, error) { logs, sub, err := _IcyBtcSwap.contract.WatchLogs(opts, "SetSigner") if err != nil { return nil, err } return event.NewSubscription(func(quit <-chan struct{}) error { defer sub.Unsubscribe() for { select { case log := <-logs: // New log arrived, parse the event and forward to the user event := new(IcyBtcSwapSetSigner) if err := _IcyBtcSwap.contract.UnpackLog(event, "SetSigner", log); err != nil { return err } event.Raw = log select { case sink <- event: case err := <-sub.Err(): return err case <-quit: return nil } case err := <-sub.Err(): return err case <-quit: return nil } } }), nil } // ParseSetSigner is a log parse operation binding the contract event 0xbb10aee7ef5a307b8097c6a7f2892b909ff1736fd24a6a5260640c185f7153b6. // // Solidity: event SetSigner(address signerAddress) func (_IcyBtcSwap *IcyBtcSwapFilterer) ParseSetSigner(log types.Log) (*IcyBtcSwapSetSigner, error) { event := new(IcyBtcSwapSetSigner) if err := _IcyBtcSwap.contract.UnpackLog(event, "SetSigner", log); err != nil { return nil, err } event.Raw = log return event, nil } // IcyBtcSwapSwapIterator is returned from FilterSwap and is used to iterate over the raw logs and unpacked data for Swap events raised by the IcyBtcSwap contract. type IcyBtcSwapSwapIterator struct { Event *IcyBtcSwapSwap // Event containing the contract specifics and raw log contract *bind.BoundContract // Generic contract to use for unpacking event data event string // Event name to use for unpacking event data logs chan types.Log // Log channel receiving the found contract events sub ethereum.Subscription // Subscription for errors, completion and termination done bool // Whether the subscription completed delivering logs fail error // Occurred error to stop iteration } // Next advances the iterator to the subsequent event, returning whether there // are any more events found. In case of a retrieval or parsing error, false is // returned and Error() can be queried for the exact failure. func (it *IcyBtcSwapSwapIterator) Next() bool { // If the iterator failed, stop iterating if it.fail != nil { return false } // If the iterator completed, deliver directly whatever's available if it.done { select { case log := <-it.logs: it.Event = new(IcyBtcSwapSwap) if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil { it.fail = err return false } it.Event.Raw = log return true default: return false } } // Iterator still in progress, wait for either a data or an error event select { case log := <-it.logs: it.Event = new(IcyBtcSwapSwap) if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil { it.fail = err return false } it.Event.Raw = log return true case err := <-it.sub.Err(): it.done = true it.fail = err return it.Next() } } // Error returns any retrieval or parsing error occurred during filtering. func (it *IcyBtcSwapSwapIterator) Error() error { return it.fail } // Close terminates the iteration process, releasing any pending underlying // resources. func (it *IcyBtcSwapSwapIterator) Close() error { it.sub.Unsubscribe() return nil } // IcyBtcSwapSwap represents a Swap event raised by the IcyBtcSwap contract. type IcyBtcSwapSwap struct { IcyAmount *big.Int BtcAddress string BtcAmount *big.Int Raw types.Log // Blockchain specific contextual infos } // FilterSwap is a free log retrieval operation binding the contract event 0x6a7e3add5ba4ffd84c70888b34c2abc4eb346e94dbd82a1ba6dd8e335c682063. // // Solidity: event Swap(uint256 icyAmount, string btcAddress, uint256 btcAmount) func (_IcyBtcSwap *IcyBtcSwapFilterer) FilterSwap(opts *bind.FilterOpts) (*IcyBtcSwapSwapIterator, error) { logs, sub, err := _IcyBtcSwap.contract.FilterLogs(opts, "Swap") if err != nil { return nil, err } return &IcyBtcSwapSwapIterator{contract: _IcyBtcSwap.contract, event: "Swap", logs: logs, sub: sub}, nil } // WatchSwap is a free log subscription operation binding the contract event 0x6a7e3add5ba4ffd84c70888b34c2abc4eb346e94dbd82a1ba6dd8e335c682063. // // Solidity: event Swap(uint256 icyAmount, string btcAddress, uint256 btcAmount) func (_IcyBtcSwap *IcyBtcSwapFilterer) WatchSwap(opts *bind.WatchOpts, sink chan<- *IcyBtcSwapSwap) (event.Subscription, error) { logs, sub, err := _IcyBtcSwap.contract.WatchLogs(opts, "Swap") if err != nil { return nil, err } return event.NewSubscription(func(quit <-chan struct{}) error { defer sub.Unsubscribe() for { select { case log := <-logs: // New log arrived, parse the event and forward to the user event := new(IcyBtcSwapSwap) if err := _IcyBtcSwap.contract.UnpackLog(event, "Swap", log); err != nil { return err } event.Raw = log select { case sink <- event: case err := <-sub.Err(): return err case <-quit: return nil } case err := <-sub.Err(): return err case <-quit: return nil } } }), nil } // ParseSwap is a log parse operation binding the contract event 0x6a7e3add5ba4ffd84c70888b34c2abc4eb346e94dbd82a1ba6dd8e335c682063. // // Solidity: event Swap(uint256 icyAmount, string btcAddress, uint256 btcAmount) func (_IcyBtcSwap *IcyBtcSwapFilterer) ParseSwap(log types.Log) (*IcyBtcSwapSwap, error) { event := new(IcyBtcSwapSwap) if err := _IcyBtcSwap.contract.UnpackLog(event, "Swap", log); err != nil { return nil, err } event.Raw = log return event, nil }
```

# internal/baserpc/baserpc.go

```go
package baserpc import ( "github.com/ethereum/go-ethereum/accounts/abi/bind" "github.com/ethereum/go-ethereum/common" "github.com/ethereum/go-ethereum/ethclient" "github.com/dwarvesf/icy-backend/contracts/erc20" "github.com/dwarvesf/icy-backend/internal/model" "github.com/dwarvesf/icy-backend/internal/utils/config" "github.com/dwarvesf/icy-backend/internal/utils/logger" ) type erc20Service struct { address common.Address instance *erc20.Erc20 } type BaseRPC struct { appConfig *config.AppConfig logger *logger.Logger erc20Service erc20Service } func New(appConfig *config.AppConfig, logger *logger.Logger) (IBaseRPC, error) { client, err := ethclient.Dial(appConfig.Blockchain.BaseRPCEndpoint) if err != nil { return nil, err } icyAddress := common.HexToAddress(appConfig.Blockchain.ICYContractAddr) icy, err := erc20.NewErc20(icyAddress, client) if err != nil { return nil, err } return &BaseRPC{ erc20Service: erc20Service{ address: icyAddress, instance: icy, }, appConfig: appConfig, logger: logger, }, nil } func (b *BaseRPC) ICYBalanceOf(address string) (*model.Web3BigInt, error) { balance, err := b.erc20Service.instance.BalanceOf(&bind.CallOpts{}, common.HexToAddress(address)) if err != nil { return nil, err } return &model.Web3BigInt{ Value: balance.String(), Decimal: 18, }, nil } func (b *BaseRPC) ICYTotalSupply() (*model.Web3BigInt, error) { totalSupply, err := b.erc20Service.instance.TotalSupply(&bind.CallOpts{}) if err != nil { return nil, err } return &model.Web3BigInt{ Value: totalSupply.String(), Decimal: 18, }, nil }
```

# internal/baserpc/interface.go

```go
package baserpc import "github.com/dwarvesf/icy-backend/internal/model" type IBaseRPC interface { ICYBalanceOf(address string) (*model.Web3BigInt, error) ICYTotalSupply() (*model.Web3BigInt, error) }
```

# internal/btcrpc/blockstream/blockstream.go

```go
package blockstream import ( "encoding/json" "fmt" "io" "net/http" "strconv" "strings" "github.com/dwarvesf/icy-backend/internal/model" "github.com/dwarvesf/icy-backend/internal/utils/config" "github.com/dwarvesf/icy-backend/internal/utils/logger" ) type blockstream struct { baseURL string client *http.Client logger *logger.Logger } func New(cfg *config.AppConfig, logger *logger.Logger) IBlockStream { return &blockstream{ baseURL: cfg.Bitcoin.BlockstreamAPIURL, client: &http.Client{}, logger: logger, } } func (c *blockstream) BroadcastTx(txHex string) (string, error) { url := fmt.Sprintf("%s/tx", c.baseURL) payload := strings.NewReader(txHex) req, err := http.NewRequest("POST", url, payload) if err != nil { return "", fmt.Errorf("failed to create request: %v", err) } req.Header.Add("Content-Type", "text/plain") resp, err := c.client.Do(req) if err != nil { return "", fmt.Errorf("failed to broadcast transaction: %v", err) } defer resp.Body.Close() body, err := io.ReadAll(resp.Body) if err != nil { return "", fmt.Errorf("failed to read response: %v", err) } if resp.StatusCode != 200 { return "", fmt.Errorf("failed to broadcast transaction: %s", string(body)) } return string(body), nil } // EstimateFee returns a map of confirmation target times (in blocks) to fee rates (in sat/vB) // Example response: // // { // "1": 25.0, // 25 sat/vB for next block // "2": 20.0, // 20 sat/vB for 2 blocks // "3": 15.0, // 15 sat/vB for 3 blocks // "6": 10.0 // 10 sat/vB for 6 blocks // } func (c *blockstream) EstimateFees() (fees map[string]float64, err error) { url := fmt.Sprintf("%s/fee-estimates", c.baseURL) resp, err := c.client.Get(url) if err != nil { return nil, fmt.Errorf("failed to get fee estimates: %v", err) } defer resp.Body.Close() if err := json.NewDecoder(resp.Body).Decode(&fees); err != nil { return nil, fmt.Errorf("failed to parse fee estimates: %v", err) } return fees, nil } func (c *blockstream) GetUTXOs(address string) ([]UTXO, error) { url := fmt.Sprintf("%s/address/%s/utxo", c.baseURL, address) resp, err := c.client.Get(url) if err != nil { return nil, fmt.Errorf("failed to get UTXOs: %v", err) } defer resp.Body.Close() var utxos []UTXO if err := json.NewDecoder(resp.Body).Decode(&utxos); err != nil { return nil, fmt.Errorf("failed to parse UTXOs: %v", err) } return utxos, nil } func (c *blockstream) GetBTCBalance(address string) (*model.Web3BigInt, error) { url := fmt.Sprintf("%s/address/%s", c.baseURL, address) var lastErr error maxRetries := 3 for attempt := 1; attempt <= maxRetries; attempt++ { resp, err := c.client.Get(url) if err != nil { lastErr = err c.logger.Error("[getBTCBalance][client.Get]", map[string]string{ "error": err.Error(), "attempt": strconv.Itoa(attempt), }) continue } if resp.StatusCode != http.StatusOK { lastErr = err c.logger.Error("[getBTCBalance][client.Get]", map[string]string{ "error": "unexpected status code", "attempt": strconv.Itoa(attempt), }) resp.Body.Close() continue } body, err := io.ReadAll(resp.Body) resp.Body.Close() if err != nil { lastErr = err c.logger.Error("[getBTCBalance][io.ReadAll]", map[string]string{ "error": err.Error(), "attempt": strconv.Itoa(attempt), }) continue } var response *GetBalanceResponse err = json.Unmarshal(body, &response) if err != nil { lastErr = err c.logger.Error("[getBTCBalance][json.Unmarshal]", map[string]string{ "error": err.Error(), "attempt": strconv.Itoa(attempt), }) continue } return &model.Web3BigInt{ Value: strconv.Itoa(response.ChainStats.FundedTxoSum), Decimal: 10, }, nil } return nil, lastErr } func (c *blockstream) GetTransactionsByAddress(address string, fromTxID string) ([]Transaction, error) { var url string if fromTxID == "" { url = fmt.Sprintf("%s/address/%s/txs", c.baseURL, address) } else { url = fmt.Sprintf("%s/address/%s/txs/chain/%s", c.baseURL, address, fromTxID) } var lastErr error maxRetries := 3 for attempt := 1; attempt <= maxRetries; attempt++ { resp, err := c.client.Get(url) if err != nil { lastErr = err c.logger.Error("[GetTransactionsByAddress][client.Get]", map[string]string{ "error": err.Error(), "attempt": strconv.Itoa(attempt), }) continue } defer resp.Body.Close() if resp.StatusCode != http.StatusOK { lastErr = fmt.Errorf("unexpected status code: %d", resp.StatusCode) c.logger.Error("[GetTransactionsByAddress][client.Get]", map[string]string{ "error": "unexpected status code", "attempt": strconv.Itoa(attempt), }) continue } var txs []Transaction if err := json.NewDecoder(resp.Body).Decode(&txs); err != nil { lastErr = err c.logger.Error("[GetTransactionsByAddress][json.NewDecoder.Decode]", map[string]string{ "error": err.Error(), }) continue } return txs, nil } return nil, lastErr }
```

# internal/btcrpc/blockstream/interface.go

```go
package blockstream import "github.com/dwarvesf/icy-backend/internal/model" type IBlockStream interface { BroadcastTx(txHex string) (hash string, err error) EstimateFees() (fees map[string]float64, err error) GetUTXOs(address string) ([]UTXO, error) GetBTCBalance(address string) (balance *model.Web3BigInt, err error) GetTransactionsByAddress(address string, fromTxID string) ([]Transaction, error) }
```

# internal/btcrpc/blockstream/types.go

```go
package blockstream type UTXO struct { TxID string `json:"txid"` Vout uint32 `json:"vout"` Value int64 `json:"value"` Status struct { Confirmed bool `json:"confirmed"` } `json:"status"` } // ChainStats represents the statistics of the blockchain referring to the transactions that have been committed to the blockchain. type ChainStats struct { FundedTxoCount int `json:"funded_txo_count"` FundedTxoSum int `json:"funded_txo_sum"` SpentTxoCount int `json:"spent_txo_count"` SpentTxoSum int `json:"spent_txo_sum"` TxCount int `json:"tx_count"` } // MempoolStats represents memory pool referring to the transactions that is in the memory // of the node but has not been committed to the blockchain in the block yet. type MempoolStats struct { FundedTxoCount int `json:"funded_txo_count"` FundedTxoSum int `json:"funded_txo_sum"` SpentTxoCount int `json:"spent_txo_count"` SpentTxoSum int `json:"spent_txo_sum"` TxCount int `json:"tx_count"` } type GetBalanceResponse struct { Address string `json:"address"` ChainStats ChainStats `json:"chain_stats"` MempoolStats MempoolStats `json:"mempool_stats"` } // Transaction represents a Bitcoin transaction from the Esplora API type Transaction struct { TxID string `json:"txid"` Version int32 `json:"version"` Locktime uint32 `json:"locktime"` Size uint32 `json:"size"` Weight uint32 `json:"weight"` Fee int64 `json:"fee"` Vin []Input `json:"vin"` Vout []Output `json:"vout"` Status TxStatus `json:"status"` } // Input represents a transaction input type Input struct { TxID string `json:"txid"` Vout uint32 `json:"vout"` Prevout *Output `json:"prevout"` ScriptSig string `json:"scriptsig"` ScriptSigAsm string `json:"scriptsig_asm"` Witness []string `json:"witness"` IsCoinbase bool `json:"is_coinbase"` Sequence uint32 `json:"sequence"` } // Output represents a transaction output type Output struct { ScriptPubKey string `json:"scriptpubkey"` ScriptPubKeyAsm string `json:"scriptpubkey_asm"` ScriptPubKeyType string `json:"scriptpubkey_type"` ScriptPubKeyAddress string `json:"scriptpubkey_address"` Value int64 `json:"value"` } // TxStatus represents the status of a transaction type TxStatus struct { Confirmed bool `json:"confirmed"` BlockHeight uint32 `json:"block_height,omitempty"` BlockHash string `json:"block_hash,omitempty"` BlockTime int64 `json:"block_time,omitempty"` }
```

# internal/btcrpc/btcrpc.go

```go
package btcrpc import ( "fmt" "strconv" "github.com/btcsuite/btcd/btcutil" "github.com/btcsuite/btcd/chaincfg" "github.com/dwarvesf/icy-backend/internal/btcrpc/blockstream" "github.com/dwarvesf/icy-backend/internal/model" "github.com/dwarvesf/icy-backend/internal/utils/config" "github.com/dwarvesf/icy-backend/internal/utils/logger" ) var ( // NetworkParams can be used to toggle between testnet and mainnet NetworkParams = &chaincfg.TestNet3Params ) type BtcRpc struct { appConfig *config.AppConfig logger *logger.Logger blockstream blockstream.IBlockStream } func New(appConfig *config.AppConfig, logger *logger.Logger) IBtcRpc { return &BtcRpc{ appConfig: appConfig, logger: logger, blockstream: blockstream.New(appConfig, logger), } } func (b *BtcRpc) Send(receiverAddressStr string, amount *model.Web3BigInt) error { // Get sender's priv key and address privKey, senderAddress, err := b.getSelfPrivKeyAndAddress(b.appConfig.Bitcoin.WalletWIF) if err != nil { b.logger.Error("[btcrpc.Send][getSelfPrivKeyAndAddress]", map[string]string{ "error": err.Error(), }) return fmt.Errorf("failed to get self private key: %v", err) } // Get receiver's address receiverAddress, err := btcutil.DecodeAddress(receiverAddressStr, NetworkParams) if err != nil { b.logger.Error("[btcrpc.Send][DecodeAddress]", map[string]string{ "error": err.Error(), }) return err } amountToSend, ok := amount.Int64() if !ok { b.logger.Error("[btcrpc.Send][Int64]", map[string]string{ "value": amount.Value, }) return fmt.Errorf("failed to convert amount to int64") } // Select required UTXOs and calculate change amount selectedUTXOs, changeAmount, err := b.selectUTXOs(senderAddress.EncodeAddress(), amountToSend) if err != nil { b.logger.Error("[btcrpc.Send][selectUTXOs]", map[string]string{ "error": err.Error(), }) return err } // Create new tx and prepare inputs/outputs tx, err := b.prepareTx(selectedUTXOs, receiverAddress, senderAddress, amountToSend, changeAmount) if err != nil { b.logger.Error("[btcrpc.Send][prepareTx]", map[string]string{ "error": err.Error(), }) return err } // Sign tx err = b.sign(tx, privKey, senderAddress, selectedUTXOs) if err != nil { b.logger.Error("[btcrpc.Send][sign]", map[string]string{ "error": err.Error(), }) return err } // Serialize & broadcast tx err = b.broadcast(tx) if err != nil { b.logger.Error("[btcrpc.Send][broadcast]", map[string]string{ "error": err.Error(), }) return err } return nil } func (b *BtcRpc) CurrentBalance() (*model.Web3BigInt, error) { balance, err := b.blockstream.GetBTCBalance(b.appConfig.Blockchain.BTCTreasuryAddress) if err != nil { b.logger.Error("[CurrentBalance][GetBTCBalance]", map[string]string{ "error": err.Error(), }) return nil, err } return balance, nil } func (b *BtcRpc) GetTransactionsByAddress(address string, fromTxId string) ([]model.OnchainBtcTransaction, error) { rawTx, err := b.blockstream.GetTransactionsByAddress(address, fromTxId) if err != nil { b.logger.Error("[GetTransactionsByAddress][GetTransactionsByAddress]", map[string]string{ "error": err.Error(), }) return nil, err } // Filter out unconfirmed transactions confirmedTx := make([]blockstream.Transaction, 0) for _, tx := range rawTx { if tx.TxID == fromTxId { break } if tx.Status.Confirmed { confirmedTx = append(confirmedTx, tx) } } transactions := make([]model.OnchainBtcTransaction, 0) for _, tx := range confirmedTx { var isOutgoing bool var senderAddress string for _, input := range tx.Vin { prevOut := input.Prevout if prevOut != nil { if prevOut.ScriptPubKeyAddress == address { isOutgoing = true } else { senderAddress = prevOut.ScriptPubKeyAddress } } } if isOutgoing { for _, output := range tx.Vout { if output.ScriptPubKeyAddress != address { transactions = append(transactions, model.OnchainBtcTransaction{ TransactionHash: tx.TxID, Amount: strconv.FormatInt(output.Value, 10), Type: model.Out, OtherAddress: output.ScriptPubKeyAddress, BlockTime: tx.Status.BlockTime, InternalID: tx.TxID, Fee: strconv.FormatInt(tx.Fee, 10), }) } } } else { for _, output := range tx.Vout { if output.ScriptPubKeyAddress == address { transactions = append(transactions, model.OnchainBtcTransaction{ TransactionHash: tx.TxID, Amount: strconv.FormatInt(output.Value, 10), Type: model.In, OtherAddress: senderAddress, BlockTime: tx.Status.BlockTime, InternalID: tx.TxID, }) } } } } return transactions, nil }
```

# internal/btcrpc/helper.go

```go
package btcrpc import ( "bytes" "encoding/hex" "fmt" "sort" "github.com/btcsuite/btcd/btcutil" "github.com/btcsuite/btcd/chaincfg/chainhash" "github.com/btcsuite/btcd/txscript" "github.com/btcsuite/btcd/wire" "github.com/decred/dcrd/dcrec/secp256k1/v4" "github.com/dwarvesf/icy-backend/internal/btcrpc/blockstream" ) const ( p2wpkhInputSize = 68 // SegWit P2WPKH input size p2wpkhOutputSize = 31 // SegWit P2WPKH output size txOverhead = 10 // Transaction overhead ) // calculateTxFee estimates the transaction fee based on current network conditions func (b *BtcRpc) calculateTxFee(feeRates map[string]float64, numInputs, numOutputs, targetBlocks int) (int64, error) { // Get fee rate for target blocks target := fmt.Sprintf("%d", targetBlocks) feeRate, ok := feeRates[target] if !ok { return 0, fmt.Errorf("no fee rate available for target %d blocks", targetBlocks) } // Calculate total transaction size txSize := calculateTxSize(numInputs, numOutputs) // Calculate fee in satoshis fee := int64(float64(txSize) * feeRate) return fee, nil } // calculateTxSize calculates the total transaction size in bytes func calculateTxSize(numInputs, numOutputs int) int { return txOverhead + (numInputs * p2wpkhInputSize) + (numOutputs * p2wpkhOutputSize) } func (b *BtcRpc) getSelfPrivKeyAndAddress(wifStr string) (*secp256k1.PrivateKey, *btcutil.AddressWitnessPubKeyHash, error) { // Decode private key from WIF format wif, err := btcutil.DecodeWIF(wifStr) if err != nil { return nil, nil, fmt.Errorf("failed to decode wif: %v", err) } privKey := wif.PrivKey pubKey := privKey.PubKey() pubKeyHash := btcutil.Hash160(pubKey.SerializeCompressed()) // Create new SegWit address address, err := btcutil.NewAddressWitnessPubKeyHash(pubKeyHash, NetworkParams) if err != nil { return nil, nil, fmt.Errorf("failed to create sender address: %v", err) } return privKey, address, nil } // getSelfAddress decodes WIF private key and return address from derived public key hash func (b *BtcRpc) getSelfAddress(pubKey *secp256k1.PublicKey) (addr *btcutil.AddressWitnessPubKeyHash, err error) { pubKeyHash := btcutil.Hash160(pubKey.SerializeCompressed()) addr, err = btcutil.NewAddressWitnessPubKeyHash(pubKeyHash, NetworkParams) if err != nil { return nil, fmt.Errorf("failed to create sender address: %v", err) } return } // prepareTxInputs creates and returns transaction inputs from UTXOs func (b *BtcRpc) prepareTxInputs(utxos []blockstream.UTXO) ([]*wire.TxIn, error) { var inputs []*wire.TxIn for _, utxo := range utxos { hash, err := chainhash.NewHashFromStr(utxo.TxID) if err != nil { return nil, fmt.Errorf("failed to create hash: %v", err) } input := wire.NewTxIn(wire.NewOutPoint(hash, uint32(utxo.Vout)), nil, nil) inputs = append(inputs, input) } return inputs, nil } // prepareTxOutputs creates both recipient and change outputs func (b *BtcRpc) prepareTxOutputs( receiverAddress btcutil.Address, senderAddress *btcutil.AddressWitnessPubKeyHash, amountToSend int64, changeAmount int64, ) ([]*wire.TxOut, error) { // Prepare recipient output pkScript, err := txscript.PayToAddrScript(receiverAddress) if err != nil { return nil, fmt.Errorf("failed to create recipient output script: %v", err) } recipientOutput := wire.NewTxOut(amountToSend, pkScript) // Prepare change output changeAddress, err := btcutil.DecodeAddress(senderAddress.EncodeAddress(), NetworkParams) if err != nil { return nil, fmt.Errorf("failed to decode change address: %v", err) } changePkScript, err := txscript.PayToAddrScript(changeAddress) if err != nil { return nil, fmt.Errorf("failed to create change output script: %v", err) } changeOutput := wire.NewTxOut(changeAmount, changePkScript) return []*wire.TxOut{recipientOutput, changeOutput}, nil } // prepareTx prepares both inputs and outputs for a transaction func (b *BtcRpc) prepareTx( utxos []blockstream.UTXO, receiverAddress btcutil.Address, senderAddress *btcutil.AddressWitnessPubKeyHash, amountToSend int64, changeAmount int64, ) (*wire.MsgTx, error) { // Create new transaction tx := wire.NewMsgTx(2) // Prepare inputs inputs, err := b.prepareTxInputs(utxos) if err != nil { return nil, fmt.Errorf("failed to prepare inputs: %v", err) } // Add inputs to transaction for _, input := range inputs { tx.AddTxIn(input) } // Prepare outputs outputs, err := b.prepareTxOutputs(receiverAddress, senderAddress, amountToSend, changeAmount) if err != nil { return nil, fmt.Errorf("failed to prepare outputs: %v", err) } // Add outputs to transaction for _, output := range outputs { tx.AddTxOut(output) } return tx, nil } // sign signs the transaction with the private key for each input func (b *BtcRpc) sign( tx *wire.MsgTx, privKey *secp256k1.PrivateKey, senderAddress *btcutil.AddressWitnessPubKeyHash, selectedUTXOs []blockstream.UTXO, ) error { prevOutScript, err := txscript.PayToAddrScript(senderAddress) if err != nil { return fmt.Errorf("failed to create sender output script: %v", err) } // Sign each input with corresponding UTXO amount for i, utxo := range selectedUTXOs { prevOuts := txscript.NewCannedPrevOutputFetcher(prevOutScript, utxo.Value) witness, err := txscript.WitnessSignature( tx, txscript.NewTxSigHashes(tx, prevOuts), i, utxo.Value, prevOutScript, txscript.SigHashAll, privKey, true, ) if err != nil { return fmt.Errorf("failed to sign transaction input %d: %v", i, err) } tx.TxIn[i].Witness = witness tx.TxIn[i].SignatureScript = nil } return nil } // broadcast serializes the signed transaction and broadcasts it func (b *BtcRpc) broadcast(tx *wire.MsgTx) error { var signedTx bytes.Buffer tx.Serialize(&signedTx) txHex := hex.EncodeToString(signedTx.Bytes()) if _, err := b.blockstream.BroadcastTx(txHex); err != nil { return fmt.Errorf("failed to broadcast transaction: %v", err) } return nil } // verifyAndSelectUTXOs checks if there are sufficient funds across all UTXOs // and returns selected UTXOs that cover the required amount func (b *BtcRpc) verifyAndSelectUTXOs(address string, amountToSend, txFee int64) ([]blockstream.UTXO, bool) { utxos, err := b.blockstream.GetUTXOs(address) if err != nil { return nil, false } // Filter confirmed UTXOs and sort by value in descending order var confirmedUTXOs []blockstream.UTXO for _, utxo := range utxos { if utxo.Status.Confirmed { confirmedUTXOs = append(confirmedUTXOs, utxo) } } sort.Slice(confirmedUTXOs, func(i, j int) bool { return confirmedUTXOs[i].Value > confirmedUTXOs[j].Value }) // Calculate total required amount requiredAmount := amountToSend + txFee // Select UTXOs and calculate total amount var totalSelected int64 var selectedUTXOs []blockstream.UTXO for _, utxo := range confirmedUTXOs { selectedUTXOs = append(selectedUTXOs, utxo) totalSelected += utxo.Value if totalSelected >= requiredAmount { return selectedUTXOs, true } } return nil, false } func (b *BtcRpc) getConfirmedUTXOs(address string) ([]blockstream.UTXO, error) { utxos, err := b.blockstream.GetUTXOs(address) if err != nil { return nil, err } // Filter confirmed UTXOs and sort by value in descending order var confirmedUTXOs []blockstream.UTXO for _, utxo := range utxos { if utxo.Status.Confirmed { confirmedUTXOs = append(confirmedUTXOs, utxo) } } sort.Slice(confirmedUTXOs, func(i, j int) bool { return confirmedUTXOs[i].Value > confirmedUTXOs[j].Value }) return confirmedUTXOs, nil } // selectUTXOs picks UTXOs until we have enough to cover amountToSend + fee // returns selected UTXOs and change amount // change amount is the amount sent back to sender after sending total amount of selected UTXOs to recipient // changeAmount = total amount of selected UTXOs - amountToSend - fee func (b *BtcRpc) selectUTXOs(address string, amountToSend int64) (selected []blockstream.UTXO, changeAmount int64, err error) { confirmedUTXOs, err := b.getConfirmedUTXOs(address) if err != nil { return nil, 0, err } // Get current fee rate from mempool feeRates, err := b.blockstream.EstimateFees() if err != nil { return nil, 0, err } // Iteratively select UTXOs until we have enough to cover amount + fee var totalSelected int64 var fee int64 for _, utxo := range confirmedUTXOs { selected = append(selected, utxo) totalSelected += utxo.Value // calculate tx fee based on the size of the transaction // n inputs: number of UTXOs whose total amount can cover the required amount (amountToSend + fee) // 2 outputs: 1 output tx for sending `amountToSend` to recipient, 1 output tx for sending `changeAmount` back to sender // 6 confirmations: widely accepted standard for bitcoin transactions fee, err = b.calculateTxFee(feeRates, len(selected), 2, 6) if err != nil { return nil, 0, err } // if we have enough to cover amount + current fee => return selected UTXOs and change amount if totalSelected >= amountToSend+fee { changeAmount = totalSelected - amountToSend - fee return selected, changeAmount, nil } } return nil, 0, fmt.Errorf( "insufficient funds: have %d satoshis, need %d satoshis", totalSelected, amountToSend+fee, ) }
```

# internal/btcrpc/interface.go

```go
package btcrpc import "github.com/dwarvesf/icy-backend/internal/model" type IBtcRpc interface { Send(receiverAddress string, amount *model.Web3BigInt) error CurrentBalance() (*model.Web3BigInt, error) GetTransactionsByAddress(address string, fromTxId string) ([]model.OnchainBtcTransaction, error) }
```

# internal/controller/controller.go

```go
package controller import ( "errors" "math" "math/big" "github.com/dwarvesf/icy-backend/internal/baserpc" "github.com/dwarvesf/icy-backend/internal/btcrpc" "github.com/dwarvesf/icy-backend/internal/model" "github.com/dwarvesf/icy-backend/internal/oracle" "github.com/dwarvesf/icy-backend/internal/telemetry" "github.com/dwarvesf/icy-backend/internal/utils/config" "github.com/dwarvesf/icy-backend/internal/utils/logger" ) const ( // Maximum transaction fee threshold (5% of transaction amount) maxTxFeePercentage = 5 ) type Controller struct { baseRPC baserpc.IBaseRPC btcRPC btcrpc.IBtcRpc oracle oracle.IOracle telemetry telemetry.ITelemetry logger *logger.Logger config *config.AppConfig } func New( baseRPC baserpc.IBaseRPC, btcRPC btcrpc.IBtcRpc, oracle oracle.IOracle, telemetry telemetry.ITelemetry, logger *logger.Logger, config *config.AppConfig, ) IController { return &Controller{ baseRPC: baseRPC, btcRPC: btcRPC, oracle: oracle, telemetry: telemetry, logger: logger, config: config, } } func (c *Controller) TriggerSwap(icyAmount *model.Web3BigInt, btcAddress string) error { // First confirm latest price to ensure swap rate is valid latestPrice, err := c.ConfirmLatestPrice() if err != nil { c.logger.Error("[TriggerSwap][ConfirmLatestPrice]", map[string]string{ "error": err.Error(), }) return err } // Calculate BTC amount based on ICY amount and latest price icyFloat := icyAmount.ToFloat() priceFloat := latestPrice.ToFloat() btcFloat := icyFloat / priceFloat // Convert BTC amount to Web3BigInt with 8 decimals btcValue := new(big.Float).Mul(new(big.Float).SetFloat64(btcFloat), new(big.Float).SetFloat64(math.Pow10(8))) btcValueInt, _ := btcValue.Int(nil) btcAmount := &model.Web3BigInt{ Value: btcValueInt.String(), Decimal: 8, } // Trigger telemetry indexing to ensure latest state if err := c.telemetry.IndexBtcTransaction(); err != nil { c.logger.Error("[TriggerSwap][IndexBtcTransaction]", map[string]string{ "error": err.Error(), }) return err } // Initiate BTC transfer if conditions are met return c.TriggerSendBTC(btcAddress, btcAmount) } func (c *Controller) ConfirmLatestPrice() (*model.Web3BigInt, error) { // Get realtime price from oracle price, err := c.oracle.GetRealtimeICYBTC() if err != nil { return nil, err } // Compare with cached price to detect significant changes cachedPrice, err := c.oracle.GetCachedRealtimeICYBTC() if err != nil { return nil, err } // If price has changed significantly, wait for confirmation if c.isPriceChangedSignificantly(price, cachedPrice) { return nil, errors.New("price changed significantly, waiting for confirmation") } return price, nil } func (c *Controller) TriggerSendBTC(address string, amount *model.Web3BigInt) error { // Get current BTC balance balance, err := c.btcRPC.CurrentBalance() if err != nil { return err } // Validate sufficient balance if !c.hasSufficientBalance(balance, amount) { return errors.New("insufficient BTC balance") } // Send BTC return c.btcRPC.Send(address, amount) } func (c *Controller) WatchSwapEvents() error { // This would implement event watching logic // For now return not implemented return errors.New("event watching not implemented") } // Helper functions func (c *Controller) isPriceChangedSignificantly(current, cached *model.Web3BigInt) bool { if cached == nil { return false } currentFloat := current.ToFloat() cachedFloat := cached.ToFloat() // Calculate percentage change change := ((currentFloat - cachedFloat) / cachedFloat) * 100 return change >= 5 || change <= -5 // 5% threshold } func (c *Controller) hasSufficientBalance(balance, required *model.Web3BigInt) bool { balanceFloat := balance.ToFloat() requiredFloat := required.ToFloat() return balanceFloat >= requiredFloat }
```

# internal/controller/interface.go

```go
package controller import "github.com/dwarvesf/icy-backend/internal/model" type IController interface { // TriggerSwap initiates a swap operation with ICY amount TriggerSwap(icyAmount *model.Web3BigInt, btcAddress string) error // ConfirmLatestPrice gets and validates the latest ICY/BTC price ConfirmLatestPrice() (*model.Web3BigInt, error) // TriggerSendBTC initiates BTC transfer if tx fee is under threshold TriggerSendBTC(address string, amount *model.Web3BigInt) error // WatchSwapEvents monitors and handles swap contract events WatchSwapEvents() error }
```

# internal/handler/handler.go

```go
package handler import ( "github.com/dwarvesf/icy-backend/internal/controller" "github.com/dwarvesf/icy-backend/internal/handler/oracle" "github.com/dwarvesf/icy-backend/internal/handler/swap" oracleService "github.com/dwarvesf/icy-backend/internal/oracle" "github.com/dwarvesf/icy-backend/internal/utils/config" "github.com/dwarvesf/icy-backend/internal/utils/logger" ) type Handler struct { OracleHandler oracle.IHandler SwapHandler swap.IHandler } func New(appConfig *config.AppConfig, logger *logger.Logger, oracleSvc oracleService.IOracle, controller controller.IController) *Handler { return &Handler{ OracleHandler: oracle.New(oracleSvc, logger, appConfig), SwapHandler: swap.New(controller, logger, appConfig), } }
```

# internal/handler/oracle/interface.go

```go
package oracle import "github.com/gin-gonic/gin" type IHandler interface { GetCirculatedICY(c *gin.Context) GetTreasusyBTC(c *gin.Context) GetICYBTCRatio(c *gin.Context) GetICYBTCRatioCached(c *gin.Context) }
```

# internal/handler/oracle/oracle.go

```go
package oracle import ( "net/http" _ "github.com/dwarvesf/icy-backend/internal/model" "github.com/dwarvesf/icy-backend/internal/oracle" "github.com/dwarvesf/icy-backend/internal/utils/config" "github.com/dwarvesf/icy-backend/internal/utils/logger" "github.com/dwarvesf/icy-backend/internal/view" "github.com/gin-gonic/gin" ) type handler struct { oracle oracle.IOracle logger *logger.Logger appConfig *config.AppConfig } func New(oracle oracle.IOracle, logger *logger.Logger, appConfig *config.AppConfig) *handler { return &handler{ oracle: oracle, logger: logger, appConfig: appConfig, } } // Detail godoc // @Summary Get Circulated ICY // @Description Get Circulated ICY // @id getCirculatedICY // @Tags Oracle // @Accept json // @Produce json // @Success 200 {object} model.Web3BigInt // @Failure 500 {object} ErrorResponse // @Router /oracle/circulated-icy [get] func (h *handler) GetCirculatedICY(c *gin.Context) { circulatedICY, err := h.oracle.GetCirculatedICY() if err != nil { h.logger.Error(err.Error()) c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, err, "", "can't get circulated ICY")) return } c.JSON(http.StatusOK, view.CreateResponse[any](circulatedICY, nil, "", "")) return } // Detail godoc // @Summary Get Treasury BTC // @Description Get Treasury BTC // @id getTreasuryBTC // @Tags Oracle // @Accept json // @Produce json // @Success 200 {object} model.Web3BigInt // @Failure 500 {object} ErrorResponse // @Router /oracle/treasury-btc [get] func (h *handler) GetTreasusyBTC(c *gin.Context) { treasuryBTC, err := h.oracle.GetBTCSupply() if err != nil { h.logger.Error(err.Error()) c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, err, "", "can't get treasury BTC")) return } c.JSON(http.StatusOK, view.CreateResponse[any](treasuryBTC, nil, "", "")) return } // Detail godoc // @Summary Get ICY/BTC Realtime Price // @Description Get ICY/BTC Realtime Price // @id getICYBTCRatio // @Tags Oracle // @Accept json // @Produce json // @Success 200 {object} model.Web3BigInt // @Failure 500 {object} ErrorResponse // @Router /oracle/icy-btc-ratio [get] func (h *handler) GetICYBTCRatio(c *gin.Context) { realtimeICYBTC, err := h.oracle.GetRealtimeICYBTC() if err != nil { h.logger.Error(err.Error()) c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, err, "", "can't get realtime ICY/BTC price")) return } c.JSON(http.StatusOK, view.CreateResponse[any](realtimeICYBTC, nil, "", "")) return } // Detail godoc // @Summary Get ICY/BTC cached Price // @Description Get ICY/BTC cached Price // @id getICYBTCRatioCached // @Tags Oracle // @Accept json // @Produce json // @Success 200 {object} model.Web3BigInt // @Failure 500 {object} ErrorResponse // @Router /oracle/icy-btc-ratio-cached [get] func (h *handler) GetICYBTCRatioCached(c *gin.Context) { cachedRealtimeICYBTC, err := h.oracle.GetCachedRealtimeICYBTC() if err != nil { h.logger.Error(err.Error()) c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, err, "", "can't get cached ICY/BTC price")) return } c.JSON(http.StatusOK, view.CreateResponse[any](cachedRealtimeICYBTC, nil, "", "")) return }
```

# internal/handler/swap/interface.go

```go
package swap import "github.com/gin-gonic/gin" type IHandler interface { TriggerSwap(c *gin.Context) }
```

# internal/handler/swap/swap.go

```go
package swap import ( "net/http" "github.com/gin-gonic/gin" "github.com/dwarvesf/icy-backend/internal/controller" "github.com/dwarvesf/icy-backend/internal/model" "github.com/dwarvesf/icy-backend/internal/utils/config" "github.com/dwarvesf/icy-backend/internal/utils/logger" "github.com/dwarvesf/icy-backend/internal/view" ) type SwapRequest struct { ICYAmount string `json:"icy_amount" binding:"required"` BTCAddress string `json:"btc_address" binding:"required"` } type handler struct { controller controller.IController logger *logger.Logger appConfig *config.AppConfig } func New(controller controller.IController, logger *logger.Logger, appConfig *config.AppConfig) IHandler { return &handler{ controller: controller, logger: logger, appConfig: appConfig, } } // TriggerSwap godoc // @Summary Trigger ICY-BTC Swap // @Description Initiates a swap between ICY and BTC // @id triggerSwap // @Tags Swap // @Accept json // @Produce json // @Param request body SwapRequest true "Swap request parameters" // @Success 200 {object} view.MessageResponse // @Failure 400 {object} view.ErrorResponse // @Failure 500 {object} view.ErrorResponse // @Router /swap/trigger [post] func (h *handler) TriggerSwap(c *gin.Context) { var req SwapRequest if err := c.ShouldBindJSON(&req); err != nil { h.logger.Error("[TriggerSwap][ShouldBindJSON]", map[string]string{ "error": err.Error(), }) c.JSON(http.StatusBadRequest, view.CreateResponse[any](nil, err, req, "invalid request")) return } icyAmount := &model.Web3BigInt{ Value: req.ICYAmount, Decimal: 18, } // TODO // burn ICY, how? // trigger swap if ICY burn is successful err := h.controller.TriggerSwap(icyAmount, req.BTCAddress) if err != nil { h.logger.Error("[TriggerSwap][TriggerSwap]", map[string]string{ "error": err.Error(), }) c.JSON(http.StatusInternalServerError, view.CreateResponse[any](nil, err, nil, "failed to trigger swap")) return } // TODO // Add telemetry c.JSON(http.StatusOK, view.CreateResponse[any]("Swap triggered successfully", nil, nil, "")) }
```

# internal/model/icy_locked_treasury.go

```go
package model type IcyLockedTreasury struct { ID int `json:"id"` Address string `json:"address"` }
```

# internal/model/onchain_btc_transaction.go

```go
package model import "time" type OnchainBtcTransaction struct { ID int `json:"id"` InternalID string `json:"internal_id"` TransactionHash string `json:"transaction_hash"` BlockTime int64 `json:"block_time"` Type TransactionType `json:"type"` Amount string `json:"amount"` Fee string `json:"fee"` OtherAddress string `json:"other_address"` CreatedAt time.Time `json:"created_at"` UpdatedAt time.Time `json:"updated_at"` }
```

# internal/model/onchain_icy_transaction.go

```go
package model import "time" type TransactionType string const ( Out TransactionType = "out" In TransactionType = "in" ) type OnchainIcyTransaction struct { ID int `json:"id"` InternalID string `json:"internal_id"` TransactionHash string `json:"transaction_hash"` BlockTime int64 `json:"block_time"` Type TransactionType `json:"type"` Amount string `json:"amount"` Fee string `json:"fee"` OtherAddress string `json:"other_address"` CreatedAt time.Time `json:"created_at"` UpdatedAt time.Time `json:"updated_at"` }
```

# internal/model/web3_bigint_test.go

```go
package model import ( "testing" ) func TestWeb3BigInt_ToFloat(t *testing.T) { tests := []struct { name string input Web3BigInt expected float64 }{ { name: "simple number", input: Web3BigInt{ Value: "1000000", Decimal: 6, }, expected: 1.0, }, { name: "zero value", input: Web3BigInt{ Value: "0", Decimal: 18, }, expected: 0.0, }, { name: "large number", input: Web3BigInt{ Value: "1234567890000000000", Decimal: 18, }, expected: 1.23456789, }, { name: "small decimal", input: Web3BigInt{ Value: "123456", Decimal: 3, }, expected: 123.456, }, } for _, tt := range tests { t.Run(tt.name, func(t *testing.T) { result := tt.input.ToFloat() if result != tt.expected { t.Errorf("ToFloat() = %v, want %v", result, tt.expected) } }) } } func TestWeb3BigInt_Add(t *testing.T) { tests := []struct { name string a Web3BigInt b Web3BigInt expected *Web3BigInt }{ { name: "simple addition", a: Web3BigInt{ Value: "1000000", Decimal: 6, }, b: Web3BigInt{ Value: "2000000", Decimal: 6, }, expected: &Web3BigInt{ Value: "3000000", Decimal: 6, }, }, { name: "add zero", a: Web3BigInt{ Value: "1000000", Decimal: 18, }, b: Web3BigInt{ Value: "0", Decimal: 18, }, expected: &Web3BigInt{ Value: "1000000", Decimal: 18, }, }, { name: "different decimals", a: Web3BigInt{ Value: "1000000", Decimal: 6, }, b: Web3BigInt{ Value: "1000000", Decimal: 18, }, expected: nil, }, { name: "large numbers", a: Web3BigInt{ Value: "999999999999999999999999", Decimal: 18, }, b: Web3BigInt{ Value: "1", Decimal: 18, }, expected: &Web3BigInt{ Value: "1000000000000000000000000", Decimal: 18, }, }, } for _, tt := range tests { t.Run(tt.name, func(t *testing.T) { result := tt.a.Add(&tt.b) if result == nil && tt.expected == nil { return } if result == nil || tt.expected == nil { t.Errorf("Add() = %v, want %v", result, tt.expected) return } if result.Value != tt.expected.Value || result.Decimal != tt.expected.Decimal { t.Errorf("Add() = {%v, %v}, want {%v, %v}", result.Value, result.Decimal, tt.expected.Value, tt.expected.Decimal) } }) } } func TestWeb3BigInt_Sub(t *testing.T) { tests := []struct { name string a Web3BigInt b Web3BigInt expected *Web3BigInt }{ { name: "simple subtraction", a: Web3BigInt{ Value: "3000000", Decimal: 6, }, b: Web3BigInt{ Value: "1000000", Decimal: 6, }, expected: &Web3BigInt{ Value: "2000000", Decimal: 6, }, }, { name: "subtract to zero", a: Web3BigInt{ Value: "1000000", Decimal: 18, }, b: Web3BigInt{ Value: "1000000", Decimal: 18, }, expected: &Web3BigInt{ Value: "0", Decimal: 18, }, }, { name: "different decimals", a: Web3BigInt{ Value: "3000000", Decimal: 6, }, b: Web3BigInt{ Value: "1000000", Decimal: 18, }, expected: nil, }, { name: "negative result", a: Web3BigInt{ Value: "1000000", Decimal: 6, }, b: Web3BigInt{ Value: "2000000", Decimal: 6, }, expected: &Web3BigInt{ Value: "-1000000", Decimal: 6, }, }, } for _, tt := range tests { t.Run(tt.name, func(t *testing.T) { result := tt.a.Sub(&tt.b) if result == nil && tt.expected == nil { return } if result == nil || tt.expected == nil { t.Errorf("Sub() = %v, want %v", result, tt.expected) return } if result.Value != tt.expected.Value || result.Decimal != tt.expected.Decimal { t.Errorf("Sub() = {%v, %v}, want {%v, %v}", result.Value, result.Decimal, tt.expected.Value, tt.expected.Decimal) } }) } }
```

# internal/model/web3_bigint.go

```go
package model import ( "math" "math/big" ) type Web3BigInt struct { Value string `json:"value"` Decimal int `json:"decimal"` } func (w *Web3BigInt) Int64() (int64, bool) { amt, ok := new(big.Int).SetString(w.Value, 10) if !ok { return 0, false } return amt.Int64(), true } func (w *Web3BigInt) ToFloat() float64 { num := new(big.Int) num.SetString(w.Value, 10) floatNum := new(big.Float).SetInt(num) divisor := new(big.Float).SetFloat64(math.Pow(10, float64(w.Decimal))) floatNum.Quo(floatNum, divisor) result, _ := floatNum.Float64() return result } func (w *Web3BigInt) Add(number *Web3BigInt) *Web3BigInt { if w.Decimal != number.Decimal { return nil } num1 := new(big.Int) num1.SetString(w.Value, 10) num2 := new(big.Int) num2.SetString(number.Value, 10) result := new(big.Int) result.Add(num1, num2) return &Web3BigInt{ Value: result.String(), Decimal: w.Decimal, } } func (w *Web3BigInt) Sub(number *Web3BigInt) *Web3BigInt { if w.Decimal != number.Decimal { return nil } num1 := new(big.Int) num1.SetString(w.Value, 10) num2 := new(big.Int) num2.SetString(number.Value, 10) result := new(big.Int) result.Sub(num1, num2) return &Web3BigInt{ Value: result.String(), Decimal: w.Decimal, } }
```

# internal/oracle/interface.go

```go
package oracle import "github.com/dwarvesf/icy-backend/internal/model" type IOracle interface { // GetCirculatedICY returns the number of circulated ICY // excludes the ICY that is locked in the treasury GetCirculatedICY() (*model.Web3BigInt, error) // GetBTCSupply returns the total supply of BTC in treasury wallet GetBTCSupply() (*model.Web3BigInt, error) // GetRealtimeICYBTC returns the realtime ICY/BTC price GetRealtimeICYBTC() (*model.Web3BigInt, error) // GetCachedRealtimeICYBTC returns the cached realtime ICY/BTC price GetCachedRealtimeICYBTC() (*model.Web3BigInt, error) }
```

# internal/oracle/oracle.go

```go
package oracle import ( "sync" "gorm.io/gorm" "github.com/dwarvesf/icy-backend/internal/baserpc" "github.com/dwarvesf/icy-backend/internal/btcrpc" "github.com/dwarvesf/icy-backend/internal/model" "github.com/dwarvesf/icy-backend/internal/store" "github.com/dwarvesf/icy-backend/internal/utils/config" "github.com/dwarvesf/icy-backend/internal/utils/logger" ) type IcyOracle struct { mux *sync.Mutex cachedICYBTC *model.Web3BigInt db *gorm.DB store *store.Store appConfig *config.AppConfig logger *logger.Logger btcRpc btcrpc.IBtcRpc baseRpc baserpc.IBaseRPC } // TODO: add other smaller packages if needed, e.g btcRPC or baseRPC func New(db *gorm.DB, store *store.Store, appConfig *config.AppConfig, logger *logger.Logger, btcRpc btcrpc.IBtcRpc, baseRpc baserpc.IBaseRPC) IOracle { o := &IcyOracle{ db: db, store: store, mux: &sync.Mutex{}, appConfig: appConfig, logger: logger, btcRpc: btcRpc, baseRpc: baseRpc, } // go o.startUpdateCachedRealtimeICYBTC() return o } func (o *IcyOracle) GetCirculatedICY() (*model.Web3BigInt, error) { icyTreasuries, err := o.store.IcyLockedTreasury.All(o.db) if err != nil { o.logger.Error("[GetCirculatedICY][ICyLockedTreasury]", map[string]string{ "error": err.Error(), }) return nil, err } totalSupply, err := o.baseRpc.ICYTotalSupply() if err != nil { o.logger.Error("[GetCirculatedICY][ICYTotalSupply]", map[string]string{ "error": err.Error(), }) return nil, err } sum := &model.Web3BigInt{ Value: "0", Decimal: 18, } for _, treasury := range icyTreasuries { balance, err := o.baseRpc.ICYBalanceOf(treasury.Address) if err != nil { o.logger.Error("[IcyOracle][GetCirculatedICY]", map[string]string{ "error": err.Error(), }) return nil, err } sum = sum.Add(balance) } return totalSupply.Sub(sum), nil } func (o *IcyOracle) GetBTCSupply() (*model.Web3BigInt, error) { btcBalance, err := o.btcRpc.CurrentBalance() if err != nil { o.logger.Error("[GetBTCSupply][CurrentBalance]", map[string]string{ "error": err.Error(), }) return nil, err } return btcBalance, nil } func (o *IcyOracle) GetRealtimeICYBTC() (*model.Web3BigInt, error) { circulatedICY, err := o.GetCirculatedICY() if err != nil { o.logger.Error("[GetRealtimeICYBTC][GetCirculatedICY]", map[string]string{ "error": err.Error(), }) return nil, err } btcSupply, err := o.GetBTCSupply() if err != nil { o.logger.Error("[GetRealtimeICYBTC][GetBTCSupply]", map[string]string{ "error": err.Error(), }) return nil, err } icybtcRate, err := getConversionRatio(circulatedICY, btcSupply) if err != nil { o.logger.Error("[GetRealtimeICYBTC][getConversionRatio]", map[string]string{ "error": err.Error(), }) return nil, err } o.updateCachedRealtimeICYBTC(icybtcRate) return icybtcRate, nil } func (o *IcyOracle) GetCachedRealtimeICYBTC() (*model.Web3BigInt, error) { o.mux.Lock() defer o.mux.Unlock() return o.cachedICYBTC, nil } func (o *IcyOracle) updateCachedRealtimeICYBTC(number *model.Web3BigInt) { o.mux.Lock() defer o.mux.Unlock() o.cachedICYBTC = number }
```

# internal/oracle/util_test.go

```go
package oracle import ( "testing" "github.com/dwarvesf/icy-backend/internal/model" "github.com/stretchr/testify/assert" ) func TestGetConversionRatio(t *testing.T) { tests := []struct { name string circulatedIcy *model.Web3BigInt btcSupply *model.Web3BigInt want *model.Web3BigInt wantErr error }{ { name: "success - normal case", circulatedIcy: &model.Web3BigInt{ Value: "1000000000000000000", // 1 ICY with 18 decimals Decimal: 18, }, btcSupply: &model.Web3BigInt{ Value: "20000000000", // 2 BTC with 10 decimals Decimal: 10, }, want: &model.Web3BigInt{ Value: "500000", // 0.5 with 6 decimals Decimal: 6, }, wantErr: nil, }, { name: "error - btc supply is zero", circulatedIcy: &model.Web3BigInt{ Value: "1000000000000000000", Decimal: 18, }, btcSupply: &model.Web3BigInt{ Value: "0", Decimal: 10, }, want: &model.Web3BigInt{ Value: "0", // 0.5 with 6 decimals Decimal: 6, }, wantErr: nil, }, { name: "success - large numbers", circulatedIcy: &model.Web3BigInt{ Value: "100000000000000000000000", // 100,000 ICY with 18 decimals Decimal: 18, }, btcSupply: &model.Web3BigInt{ Value: "100000000000", // 10,000 BTC with 10 decimals Decimal: 10, }, want: &model.Web3BigInt{ Value: "10000000000", // 10 with 6 decimals Decimal: 6, }, wantErr: nil, }, } for _, tt := range tests { t.Run(tt.name, func(t *testing.T) { got, err := getConversionRatio(tt.circulatedIcy, tt.btcSupply) if tt.wantErr != nil { assert.Error(t, err) assert.Equal(t, tt.wantErr, err) assert.Nil(t, got) return } assert.NoError(t, err) assert.NotNil(t, got) assert.Equal(t, tt.want.Value, got.Value) assert.Equal(t, tt.want.Decimal, got.Decimal) }) } }
```

# internal/oracle/util.go

```go
package oracle import ( "math" "math/big" "github.com/dwarvesf/icy-backend/internal/model" ) func getConversionRatio(circulatedIcy, btcSupply *model.Web3BigInt) (*model.Web3BigInt, error) { icyFloat := circulatedIcy.ToFloat() btcFloat := btcSupply.ToFloat() if btcFloat == 0 { return &model.Web3BigInt{ Value: "0", Decimal: 6, }, nil } ratio := icyFloat / btcFloat ratioFloat := new(big.Float).SetFloat64(ratio) multiplier := new(big.Float).SetFloat64(math.Pow(10, 6)) ratioFloat.Mul(ratioFloat, multiplier) ratioInt := new(big.Int) ratioFloat.Int(ratioInt) return &model.Web3BigInt{ Value: ratioInt.String(), Decimal: 6, }, nil }
```

# internal/server/server.go

```go
package server import ( "github.com/robfig/cron/v3" "github.com/dwarvesf/icy-backend/internal/baserpc" "github.com/dwarvesf/icy-backend/internal/btcrpc" "github.com/dwarvesf/icy-backend/internal/controller" "github.com/dwarvesf/icy-backend/internal/oracle" "github.com/dwarvesf/icy-backend/internal/store" pgstore "github.com/dwarvesf/icy-backend/internal/store/postgres" "github.com/dwarvesf/icy-backend/internal/telemetry" "github.com/dwarvesf/icy-backend/internal/transport/http" "github.com/dwarvesf/icy-backend/internal/utils/config" "github.com/dwarvesf/icy-backend/internal/utils/logger" ) func Init() { appConfig := config.New() logger := logger.New(appConfig.Environment) db := pgstore.New(appConfig, logger) s := store.New() btcRpc := btcrpc.New(appConfig, logger) baseRpc, err := baserpc.New(appConfig, logger) if err != nil { logger.Error("Failed to init base rpc") return } oracle := oracle.New(db, s, appConfig, logger, btcRpc, baseRpc) telemetry := telemetry.New(db, s, appConfig, logger, btcRpc) // Initialize contract controller contractController := controller.New( baseRpc, btcRpc, oracle, telemetry, logger, appConfig, ) c := cron.New() // Add cron jobs c.AddFunc("@every 2m", func() { telemetry.IndexBtcTransaction() }) // Add contract event watching c.AddFunc("@every 1m", func() { if err := contractController.WatchSwapEvents(); err != nil { logger.Error("Failed to watch swap events", map[string]string{ "error": err.Error(), }) } }) c.Start() httpServer := http.NewHttpServer(appConfig, logger, oracle, contractController) httpServer.Run() }
```

# internal/store/icylockedtreasury/icy_locked_treasury.go

```go
package icylockedtreasury import ( "gorm.io/gorm" "github.com/dwarvesf/icy-backend/internal/model" ) type store struct{} func New() IStore { return &store{} } func (s *store) All(db *gorm.DB) ([]*model.IcyLockedTreasury, error) { var icyLockedTreasuries []*model.IcyLockedTreasury return icyLockedTreasuries, db.Find(&icyLockedTreasuries).Error }
```

# internal/store/icylockedtreasury/interface.go

```go
package icylockedtreasury import ( "gorm.io/gorm" "github.com/dwarvesf/icy-backend/internal/model" ) type IStore interface { All(db *gorm.DB) ([]*model.IcyLockedTreasury, error) }
```

# internal/store/onchainbtctransaction/interface.go

```go
package onchainbtctransaction import ( "github.com/dwarvesf/icy-backend/internal/model" "gorm.io/gorm" ) type IStore interface { Create(db *gorm.DB, onchainBtcTransaction *model.OnchainBtcTransaction) (*model.OnchainBtcTransaction, error) GetLatestTransaction(db *gorm.DB) (*model.OnchainBtcTransaction, error) }
```

# internal/store/onchainbtctransaction/onchain_btc_transaction.go

```go
package onchainbtctransaction import ( "github.com/dwarvesf/icy-backend/internal/model" "gorm.io/gorm" ) type store struct{} func New() IStore { return &store{} } func (s *store) Create(db *gorm.DB, onchainBtcTransaction *model.OnchainBtcTransaction) (*model.OnchainBtcTransaction, error) { return onchainBtcTransaction, db.Create(onchainBtcTransaction).Error } func (s *store) GetLatestTransaction(db *gorm.DB) (*model.OnchainBtcTransaction, error) { var onchainBtcTransaction model.OnchainBtcTransaction return &onchainBtcTransaction, db.Order("created_at desc").First(&onchainBtcTransaction).Error }
```

# internal/store/onchainicytransaction/interface.go

```go
package onchainicytransaction import ( "github.com/dwarvesf/icy-backend/internal/model" "gorm.io/gorm" ) type IStore interface { Create(db *gorm.DB, onchainIcyTransaction *model.OnchainIcyTransaction) (*model.OnchainIcyTransaction, error) }
```

# internal/store/onchainicytransaction/onchain_icy_transaction.go

```go
package onchainicytransaction import ( "github.com/dwarvesf/icy-backend/internal/model" "gorm.io/gorm" ) type store struct{} func New() IStore { return &store{} } func (s *store) Create(db *gorm.DB, onchainIcyTransaction *model.OnchainIcyTransaction) (*model.OnchainIcyTransaction, error) { return onchainIcyTransaction, db.Create(onchainIcyTransaction).Error }
```

# internal/store/postgres/postgres.go

```go
package pgstore import ( "fmt" "gorm.io/driver/postgres" "gorm.io/gorm" "gorm.io/gorm/schema" "github.com/dwarvesf/icy-backend/internal/utils/config" "github.com/dwarvesf/icy-backend/internal/utils/logger" ) type PostgresStore struct { db *gorm.DB } func New(appConfig *config.AppConfig, logger *logger.Logger) *gorm.DB { conn, err := connectPostgres(appConfig) if err != nil { logger.Fatal("failed to connect to postgres", map[string]string{ "error": err.Error(), }) } return conn } func connectPostgres(appConfig *config.AppConfig) (*gorm.DB, error) { ds := fmt.Sprintf( "host=%s user=%s password=%s dbname=%s port=%s sslmode=%s", appConfig.Postgres.Host, appConfig.Postgres.User, appConfig.Postgres.Pass, appConfig.Postgres.Name, appConfig.Postgres.Port, appConfig.Postgres.SSLMode, ) db, err := gorm.Open(postgres.Open(ds), &gorm.Config{ NamingStrategy: schema.NamingStrategy{ SingularTable: false, }, }) if err != nil { return nil, err } return db, nil }
```

# internal/store/store.go

```go
package store import ( "github.com/dwarvesf/icy-backend/internal/store/icylockedtreasury" "github.com/dwarvesf/icy-backend/internal/store/onchainbtctransaction" "github.com/dwarvesf/icy-backend/internal/store/onchainicytransaction" ) type Store struct { IcyLockedTreasury icylockedtreasury.IStore OnchainBtcTransaction onchainbtctransaction.IStore OnchainIcyTransaction onchainicytransaction.IStore } func New() *Store { return &Store{ IcyLockedTreasury: icylockedtreasury.New(), OnchainBtcTransaction: onchainbtctransaction.New(), OnchainIcyTransaction: onchainicytransaction.New(), } }
```

# internal/store/transaction.go

```go
package store import ( "gorm.io/gorm" ) // NewTransaction for database connection func DoInTx(db *gorm.DB, fn func(tx *gorm.DB) error) error { tx := db.Begin() if tx.Error != nil { return tx.Error } err := fn(tx) if err != nil { tx.Rollback() return err } return tx.Commit().Error }
```

# internal/telemetry/interface.go

```go
package telemetry type ITelemetry interface { IndexBtcTransaction() error IndexIcyTransaction() error }
```

# internal/telemetry/telemetry.go

```go
package telemetry import ( "errors" "fmt" "slices" "gorm.io/gorm" "github.com/dwarvesf/icy-backend/internal/btcrpc" "github.com/dwarvesf/icy-backend/internal/model" "github.com/dwarvesf/icy-backend/internal/store" "github.com/dwarvesf/icy-backend/internal/utils/config" "github.com/dwarvesf/icy-backend/internal/utils/logger" ) type Telemetry struct { db *gorm.DB store *store.Store appConfig *config.AppConfig logger *logger.Logger btcRpc btcrpc.IBtcRpc } func New(db *gorm.DB, store *store.Store, appConfig *config.AppConfig, logger *logger.Logger, btcRpc btcrpc.IBtcRpc) *Telemetry { return &Telemetry{ db: db, store: store, appConfig: appConfig, logger: logger, btcRpc: btcRpc, } } func (t *Telemetry) IndexBtcTransaction() error { t.logger.Info("[IndexBtcTransaction] Start indexing BTC transactions...") var latestTx *model.OnchainBtcTransaction latestTx, err := t.store.OnchainBtcTransaction.GetLatestTransaction(t.db) if err != nil { if !errors.Is(err, gorm.ErrRecordNotFound) { t.logger.Error("[IndexBtcTransaction][GetLatestTransaction]", map[string]string{ "error": err.Error(), }) return err } } //TODO: Should add first transaction to db manually. txHash := "" if latestTx != nil { txHash = latestTx.TransactionHash } t.logger.Info(fmt.Sprintf("[IndexBtcTransaction] Latest BTC transaction: %s", txHash)) markedTxHash := "" txs := []model.OnchainBtcTransaction{} for { markedTxs, err := t.btcRpc.GetTransactionsByAddress(t.appConfig.Blockchain.BTCTreasuryAddress, markedTxHash) if err != nil { t.logger.Error("[IndexBtcTransaction][GetTransactionsByAddress]", map[string]string{ "error": err.Error(), }) return err } for i, tx := range markedTxs { if tx.TransactionHash == txHash { markedTxs = markedTxs[:i] break } } txs = append(txs, markedTxs...) if len(markedTxs) < 25 { break } markedTxHash = markedTxs[len(markedTxs)-1].TransactionHash } slices.Reverse(txs) return store.DoInTx(t.db, func(tx *gorm.DB) error { for _, onchainTx := range txs { _, err := t.store.OnchainBtcTransaction.Create(tx, &onchainTx) if err != nil { t.logger.Error("[IndexBtcTransaction][Create]", map[string]string{ "error": err.Error(), }) return err } t.logger.Info(fmt.Sprintf("Tx Hash: %s - Amount: %s [%s]", onchainTx.TransactionHash, onchainTx.Amount, onchainTx.Type)) } return nil }) } func (t *Telemetry) IndexIcyTransaction() error { return nil }
```

# internal/transport/http/http.go

```go
package http import ( "strings" "github.com/gin-contrib/cors" "github.com/gin-gonic/gin" swaggerFiles "github.com/swaggo/files" // swagger embed files ginSwagger "github.com/swaggo/gin-swagger" // gin-swagger middleware "github.com/dwarvesf/icy-backend/internal/controller" "github.com/dwarvesf/icy-backend/internal/handler" "github.com/dwarvesf/icy-backend/internal/oracle" "github.com/dwarvesf/icy-backend/internal/utils/config" "github.com/dwarvesf/icy-backend/internal/utils/logger" ) func setupCORS(r *gin.Engine, cfg *config.AppConfig) { corsOrigins := strings.Split(cfg.ApiServer.AllowedOrigins, ";") r.Use(func(c *gin.Context) { cors.New( cors.Config{ AllowOrigins: corsOrigins, AllowMethods: []string{"GET", "POST", "PUT", "DELETE", "OPTIONS", "HEAD"}, AllowHeaders: []string{ "Origin", "Host", "Content-Type", "Content-Length", "Accept-Encoding", "Accept-Language", "Accept", "X-CSRF-Token", "Authorization", "X-Requested-With", "X-Access-Token", }, AllowCredentials: true, }, )(c) }) } func NewHttpServer(appConfig *config.AppConfig, logger *logger.Logger, oracle oracle.IOracle, controller controller.IController) *gin.Engine { r := gin.New() r.Use( gin.LoggerWithWriter(gin.DefaultWriter, "/healthz"), gin.Recovery(), ) setupCORS(r, appConfig) h := handler.New(appConfig, logger, oracle, controller) // use ginSwagger middleware to serve the API docs r.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler)) // load api loadV1Routes(r, h, appConfig, logger) return r }
```

# internal/transport/http/v1.go

```go
package http import ( "github.com/gin-gonic/gin" "github.com/dwarvesf/icy-backend/internal/handler" "github.com/dwarvesf/icy-backend/internal/utils/config" "github.com/dwarvesf/icy-backend/internal/utils/logger" ) func loadV1Routes(r *gin.Engine, h *handler.Handler, appConfig *config.AppConfig, logger *logger.Logger) { v1 := r.Group("/api/v1") oracle := v1.Group("/oracle") { oracle.GET("/circulated-icy", h.OracleHandler.GetCirculatedICY) oracle.GET("/treasury-btc", h.OracleHandler.GetTreasusyBTC) oracle.GET("/icy-btc-ratio", h.OracleHandler.GetICYBTCRatio) oracle.GET("/icy-btc-ratio-cached", h.OracleHandler.GetICYBTCRatioCached) } swap := v1.Group("/swap") { swap.POST("/trigger", h.SwapHandler.TriggerSwap) } // health check r.GET("/healthz", func(c *gin.Context) { c.JSON(200, gin.H{ "message": "ok", }) }) }
```

# internal/types/environments/environments.go

```go
package environments type Environment string const ( Production Environment = "production" Development Environment = "development" Staging Environment = "staging" Test Environment = "test" )
```

# internal/utils/config/config_suite_test.go

```go
package config import ( "testing" . "github.com/onsi/ginkgo/v2" . "github.com/onsi/gomega" ) func TestConfig(t *testing.T) { RegisterFailHandler(Fail) RunSpecs(t, "Config Suite") }
```

# internal/utils/config/config_test.go

```go
package config import ( "os" . "github.com/onsi/ginkgo/v2" ) var _ = Describe("Config", func() { Describe("#ApplicationConfig", func() { BeforeEach(func() { os.Unsetenv("LIVENESS_PROBE_PORT") }) }) })
```

# internal/utils/config/config.go

```go
package config import ( "os" "strconv" "github.com/joho/godotenv" "github.com/dwarvesf/icy-backend/internal/types/environments" ) type AppConfig struct { Environment environments.Environment ApiServer ApiServerConfig Postgres DBConnection Bitcoin BitcoinConfig Blockchain BlockchainConfig } type ApiServerConfig struct { AllowedOrigins string } type BlockchainConfig struct { BaseRPCEndpoint string ICYContractAddr string BTCTreasuryAddress string } type DBConnection struct { Host string Port string User string Name string Pass string SSLMode string } type BitcoinConfig struct { WalletWIF string BlockstreamAPIURL string } func New() *AppConfig { env := os.Getenv("APP_ENV") if env == "" { env = "development" } // this will load .env file (env from travel-exp repo) // this will not override env variables if they already exist godotenv.Load(".env." + env) return &AppConfig{ ApiServer: ApiServerConfig{ AllowedOrigins: os.Getenv("ALLOWED_ORIGINS"), }, Postgres: DBConnection{ Host: os.Getenv("DB_HOST"), Port: os.Getenv("DB_PORT"), User: os.Getenv("DB_USER"), Name: os.Getenv("DB_NAME"), Pass: os.Getenv("DB_PASS"), SSLMode: os.Getenv("DB_SSL_MODE"), }, Bitcoin: BitcoinConfig{ WalletWIF: os.Getenv("BTC_WALLET_WIF"), BlockstreamAPIURL: os.Getenv("BTC_BLOCKSTREAM_API_URL"), }, Blockchain: BlockchainConfig{ BaseRPCEndpoint: os.Getenv("BLOCKCHAIN_BASE_RPC_ENDPOINT"), ICYContractAddr: os.Getenv("BLOCKCHAIN_ICY_CONTRACT_ADDR"), BTCTreasuryAddress: os.Getenv("BLOCKCHAIN_BTC_TREASURY_ADDRESS"), }, } } func envVarAtoi(envName string) int { valueStr := os.Getenv(envName) value, err := strconv.Atoi(valueStr) if err != nil { panic(err) } return value } func envVarAsBool(envName string) bool { valueStr := os.Getenv(envName) return valueStr == "true" }
```

# internal/utils/logger/environment_test.go

```go
package logger import ( . "github.com/onsi/ginkgo/v2" . "github.com/onsi/gomega" "go.uber.org/zap" ) var _ = Describe("Logger Environment", func() { Describe("#newProductionLoggerConfig", func() { It("should return the correct production logger configuration", func() { cfg := newProductionLoggerConfig() Expect(cfg.Level.Level()).To(Equal(zap.InfoLevel)) Expect(cfg.Development).To(BeFalse()) Expect(cfg.DisableCaller).To(BeFalse()) Expect(cfg.DisableStacktrace).To(BeFalse()) Expect(cfg.Encoding).To(Equal("json")) Expect(cfg.OutputPaths).To(Equal([]string{"stdout"})) Expect(cfg.ErrorOutputPaths).To(Equal([]string{"stderr"})) }) }) Describe("#newStagingLoggerConfig", func() { It("should return the correct staging logger configuration", func() { cfg := newStagingLoggerConfig() Expect(cfg.Level.Level()).To(Equal(zap.InfoLevel)) Expect(cfg.Development).To(BeFalse()) Expect(cfg.DisableCaller).To(BeTrue()) Expect(cfg.DisableStacktrace).To(BeTrue()) Expect(cfg.Encoding).To(Equal("json")) Expect(cfg.OutputPaths).To(Equal([]string{"stdout"})) Expect(cfg.ErrorOutputPaths).To(Equal([]string{"stderr"})) }) }) Describe("#newDevelopmentLoggerConfig", func() { It("should return the correct development logger configuration", func() { cfg := newDevelopmentLoggerConfig() Expect(cfg.Level.Level()).To(Equal(zap.DebugLevel)) Expect(cfg.Development).To(BeTrue()) Expect(cfg.DisableCaller).To(BeTrue()) Expect(cfg.DisableStacktrace).To(BeTrue()) Expect(cfg.Encoding).To(Equal("console")) Expect(cfg.OutputPaths).To(Equal([]string{"stdout"})) Expect(cfg.ErrorOutputPaths).To(Equal([]string{"stderr"})) }) }) Describe("#newTestLoggerConfig", func() { It("should return the correct test logger configuration", func() { cfg := newTestLoggerConfig() Expect(cfg.Level.Level()).To(Equal(zap.InfoLevel)) Expect(cfg.Development).To(BeFalse()) Expect(cfg.DisableCaller).To(BeFalse()) Expect(cfg.DisableStacktrace).To(BeFalse()) Expect(cfg.Encoding).To(Equal("json")) Expect(cfg.OutputPaths).To(BeEmpty()) Expect(cfg.ErrorOutputPaths).To(BeEmpty()) }) }) })
```

# internal/utils/logger/environment.go

```go
package logger import ( "go.uber.org/zap" "go.uber.org/zap/zapcore" ) func newProductionLoggerConfig() zap.Config { encoderCfg := zapcore.EncoderConfig{ TimeKey: "ts", LevelKey: "level", NameKey: "logger", CallerKey: "caller", FunctionKey: zapcore.OmitKey, MessageKey: "msg", StacktraceKey: "stacktrace", LineEnding: zapcore.DefaultLineEnding, EncodeLevel: zapcore.LowercaseLevelEncoder, EncodeTime: zapcore.EpochTimeEncoder, EncodeDuration: zapcore.SecondsDurationEncoder, EncodeCaller: zapcore.ShortCallerEncoder, } cfg := zap.Config{ Level: zap.NewAtomicLevelAt(zap.InfoLevel), Development: false, DisableCaller: false, DisableStacktrace: false, Sampling: nil, Encoding: "json", EncoderConfig: encoderCfg, OutputPaths: []string{"stdout"}, ErrorOutputPaths: []string{"stderr"}, } return cfg } func newStagingLoggerConfig() zap.Config { encoderCfg := zapcore.EncoderConfig{ TimeKey: "ts", LevelKey: "level", NameKey: "logger", CallerKey: "caller", FunctionKey: zapcore.OmitKey, MessageKey: "msg", StacktraceKey: "stacktrace", LineEnding: zapcore.DefaultLineEnding, EncodeLevel: zapcore.LowercaseLevelEncoder, EncodeTime: zapcore.EpochTimeEncoder, EncodeDuration: zapcore.SecondsDurationEncoder, EncodeCaller: zapcore.ShortCallerEncoder, } cfg := zap.Config{ Level: zap.NewAtomicLevelAt(zap.InfoLevel), Development: false, DisableCaller: true, DisableStacktrace: true, Sampling: nil, Encoding: "json", EncoderConfig: encoderCfg, OutputPaths: []string{"stdout"}, ErrorOutputPaths: []string{"stderr"}, } return cfg } func newDevelopmentLoggerConfig() zap.Config { encoderCfg := zapcore.EncoderConfig{ // Keys can be anything except the empty string. TimeKey: "T", LevelKey: "L", NameKey: "N", CallerKey: "C", FunctionKey: zapcore.OmitKey, MessageKey: "M", StacktraceKey: "S", LineEnding: zapcore.DefaultLineEnding, EncodeLevel: zapcore.CapitalLevelEncoder, EncodeTime: zapcore.ISO8601TimeEncoder, EncodeDuration: zapcore.StringDurationEncoder, EncodeCaller: zapcore.ShortCallerEncoder, } cfg := zap.Config{ Level: zap.NewAtomicLevelAt(zap.DebugLevel), Development: true, DisableCaller: true, DisableStacktrace: true, Sampling: nil, Encoding: "console", EncoderConfig: encoderCfg, OutputPaths: []string{"stdout"}, ErrorOutputPaths: []string{"stderr"}, } return cfg } func newTestLoggerConfig() zap.Config { encoderCfg := zapcore.EncoderConfig{ TimeKey: "ts", LevelKey: "level", NameKey: "logger", CallerKey: "caller", FunctionKey: zapcore.OmitKey, MessageKey: "msg", StacktraceKey: "stacktrace", LineEnding: zapcore.DefaultLineEnding, EncodeLevel: zapcore.LowercaseLevelEncoder, EncodeTime: zapcore.EpochTimeEncoder, EncodeDuration: zapcore.SecondsDurationEncoder, EncodeCaller: zapcore.ShortCallerEncoder, } cfg := zap.Config{ Level: zap.NewAtomicLevelAt(zap.InfoLevel), Development: false, DisableCaller: false, DisableStacktrace: false, Sampling: nil, Encoding: "json", EncoderConfig: encoderCfg, // Disable output for test OutputPaths: []string{}, ErrorOutputPaths: []string{}, } return cfg }
```

# internal/utils/logger/logger_suite_test.go

```go
package logger import ( "testing" . "github.com/onsi/ginkgo/v2" . "github.com/onsi/gomega" ) func TestLogger(t *testing.T) { RegisterFailHandler(Fail) RunSpecs(t, "Logger Suite") }
```

# internal/utils/logger/logger_test.go

```go
package logger import ( "bytes" "sort" . "github.com/onsi/ginkgo/v2" . "github.com/onsi/gomega" "go.uber.org/zap" "go.uber.org/zap/zapcore" "github.com/dwarvesf/icy-backend/internal/types/environments" ) type customWriteHook struct { called bool } func (h *customWriteHook) OnWrite(_ *zapcore.CheckedEntry, _ []zapcore.Field) { h.called = true } var _ = Describe("Logger", func() { var logger *Logger Describe("#New", func() { It("should create a new logger with production config when environment is production", func() { logger = New(environments.Production) Expect(logger).NotTo(BeNil()) Expect(logger.wrappedLogger).NotTo(BeNil()) }) It("should create a new logger with development config when environment is development", func() { logger = New(environments.Development) Expect(logger).NotTo(BeNil()) Expect(logger.wrappedLogger).NotTo(BeNil()) }) It("should create a new logger with staging config when environment is staging", func() { logger = New(environments.Staging) Expect(logger).NotTo(BeNil()) Expect(logger.wrappedLogger).NotTo(BeNil()) }) It("should create a new logger with test config when environment is test", func() { logger = New(environments.Test) Expect(logger).NotTo(BeNil()) Expect(logger.wrappedLogger).NotTo(BeNil()) }) It("should create a new logger with production config when environment is unknown", func() { unknownEnv := environments.Environment("unknown") logger = New(unknownEnv) Expect(logger).NotTo(BeNil()) Expect(logger.wrappedLogger).NotTo(BeNil()) // Verify that the logger is configured with production settings zapLogger := logger.wrappedLogger.WithOptions(zap.AddCaller()) core := zapLogger.Core() Expect(core.Enabled(zapcore.InfoLevel)).To(BeTrue()) Expect(core.Enabled(zapcore.DebugLevel)).To(BeFalse()) }) }) Describe("#Debug", func() { BeforeEach(func() { logger = New(environments.Test) }) It("should log debug messages", func() { Expect(func() { logger.Debug("debug message", map[string]string{"key": "value"}) }).NotTo(Panic()) }) }) Describe("#Error", func() { BeforeEach(func() { logger = New(environments.Test) }) It("should log error messages", func() { Expect(func() { logger.Error("error message", map[string]string{"key": "value"}) }).NotTo(Panic()) }) }) Describe("#Info", func() { BeforeEach(func() { logger = New(environments.Test) }) It("should log info messages", func() { Expect(func() { logger.Info("info message", map[string]string{"key": "value"}) }).NotTo(Panic()) }) }) Describe("#Fatal", func() { BeforeEach(func() { logger = New(environments.Test) }) It("should log fatal messages", func() { hook := &customWriteHook{} originalLogger := logger.wrappedLogger defer func() { logger.wrappedLogger = originalLogger }() testLogger := zap.New( zapcore.NewCore( zapcore.NewConsoleEncoder(zap.NewDevelopmentEncoderConfig()), zapcore.AddSync(&bytes.Buffer{}), zap.FatalLevel, ), zap.WithFatalHook(hook), ) logger.wrappedLogger = testLogger logger.Fatal("fatal message", map[string]string{"key": "value"}) Expect(hook.called).To(BeTrue()) }) }) Describe("#transformStrMapToFields", func() { It("should transform a string map to zap fields", func() { inputMap := map[string]string{ "key1": "value1", "key2": "value2", } fields := transformStrMapToFields(inputMap) // sort fields by key sort.Slice(fields, func(i, j int) bool { return fields[i].Key < fields[j].Key }) Expect(fields).To(HaveLen(2)) Expect(fields[0]).To(Equal(zap.String("key1", "value1"))) Expect(fields[1]).To(Equal(zap.String("key2", "value2"))) }) It("should return an empty slice for an empty input map", func() { inputMap := map[string]string{} fields := transformStrMapToFields(inputMap) Expect(fields).To(BeEmpty()) }) }) })
```

# internal/utils/logger/logger.go

```go
package logger import ( "go.uber.org/zap" "github.com/dwarvesf/icy-backend/internal/types/environments" ) type Logger struct { wrappedLogger *zap.Logger } func New(env environments.Environment) *Logger { var cfg zap.Config switch env { case environments.Development: cfg = newDevelopmentLoggerConfig() case environments.Test: cfg = newTestLoggerConfig() case environments.Staging: cfg = newStagingLoggerConfig() case environments.Production: cfg = newProductionLoggerConfig() default: cfg = newProductionLoggerConfig() } zapLogger, err := cfg.Build() if err != nil { panic(err) } return &Logger{ wrappedLogger: zapLogger, } } func (l *Logger) Debug(msg string, inputFields ...map[string]string) { fields := []zap.Field{} if len(inputFields) > 0 { fields = transformStrMapToFields(inputFields[0]) } l.wrappedLogger.Debug(msg, fields...) } func (l *Logger) Error(msg string, inputFields ...map[string]string) { fields := []zap.Field{} if len(inputFields) > 0 { fields = transformStrMapToFields(inputFields[0]) } l.wrappedLogger.Error(msg, fields...) } func (l *Logger) Fatal(msg string, inputFields ...map[string]string) { fields := []zap.Field{} if len(inputFields) > 0 { fields = transformStrMapToFields(inputFields[0]) } l.wrappedLogger.Fatal(msg, fields...) } func (l *Logger) Info(msg string, inputFields ...map[string]string) { fields := []zap.Field{} if len(inputFields) > 0 { fields = transformStrMapToFields(inputFields[0]) } l.wrappedLogger.Info(msg, fields...) } func transformStrMapToFields(strMap map[string]string) []zap.Field { fields := []zap.Field{} for k, v := range strMap { fields = append(fields, zap.String(k, v)) } return fields }
```

# internal/view/response.go

```go
package view import ( "errors" "reflect" "strings" "github.com/go-playground/validator/v10" ) // ApiError is a struct for error response // @Description validation error details type ApiError struct { Field string `json:"field"` // the field cause the error Msg string `json:"msg"` // error message Enums []string `json:"enums,omitempty"` // available options incase of field's payload is enums } // @name ApiError type Response[T any] struct { Data T `json:"data"` Message string `json:"message,omitempty"` Error string `json:"error,omitempty"` ErrorDetails []ApiError `json:"errors,omitempty"` } type ErrorResponse struct { Error string `json:"error"` ErrorDetails []ApiError `json:"errors"` } // @name ErrorResponse type MessageResponse struct { Message string `json:"message"` } // @name MessageResponse type ResponseString struct { Data string `json:"data"` } // @name ResponseString func CreateResponse[T any](data T, err error, payload any, message string) Response[T] { resp := Response[T]{ Data: data, } if message != "" { resp.Message = message } var ve validator.ValidationErrors if err != nil { resp.Error = err.Error() } if err != nil && errors.As(err, &ve) { errs := make([]ApiError, len(ve)) for i, fe := range ve { var msg string var enums []string if payload != nil { field, ok := reflect.TypeOf(payload).FieldByName(fe.StructField()) if ok { msg = field.Tag.Get("msg") if len(field.Tag.Get("enums")) > 0 { enums = strings.Split(field.Tag.Get("enums"), ",") } } } if msg == "" { splitErrMsg := strings.Split(fe.Error(), "Error:") if len(splitErrMsg) > 1 { msg = splitErrMsg[1] } else { msg = splitErrMsg[0] } } errs[i] = ApiError{Field: fe.Field(), Msg: msg, Enums: enums} } resp.ErrorDetails = errs } return resp }
```

# migrations/schema/0001_add_locked_icy_treasury_table.down.sql

```sql
DROP TABLE IF EXISTS "icy_locked_treasuries";
```

# migrations/schema/0001_add_locked_icy_treasury_table.up.sql

```sql
-- +migrate Up CREATE TABLE "icy_locked_treasuries" ( "id" SERIAL PRIMARY KEY, "address" VARCHAR NOT NULL, "created_at" TIMESTAMP NOT NULL DEFAULT now(), "updated_at" TIMESTAMP NOT NULL DEFAULT now() );
```

# migrations/schema/0002_add_onchain_transaction_tables.down.sql

```sql
DROP TABLE IF EXISTS "onchain_icy_transactions"; DROP TABLE IF EXISTS "onchain_btc_transactions";
```

# migrations/schema/0002_add_onchain_transaction_tables.up.sql

```sql
CREATE TABLE "onchain_icy_transactions" ( "id" SERIAL PRIMARY KEY, "internal_id" VARCHAR NOT NULL, "transaction_hash" VARCHAR NOT NULL, "block_time" INTEGER, "type" VARCHAR NOT NULL, "amount" VARCHAR NOT NULL, "other_address" VARCHAR NOT NULL, "fee" VARCHAR, "created_at" TIMESTAMP NOT NULL DEFAULT now(), "updated_at" TIMESTAMP NOT NULL DEFAULT now() ); CREATE TABLE "onchain_btc_transactions" ( "id" SERIAL PRIMARY KEY, "internal_id" VARCHAR NOT NULL, "transaction_hash" VARCHAR NOT NULL, "block_time" INTEGER, "type" VARCHAR NOT NULL, "amount" VARCHAR NOT NULL, "other_address" VARCHAR NOT NULL, "fee" VARCHAR, "created_at" TIMESTAMP NOT NULL DEFAULT now(), "updated_at" TIMESTAMP NOT NULL DEFAULT now() );
```

